{"version":3,"file":"index.js","sources":["../src/diffDOM/dom/fromVirtual.js","../src/diffDOM/dom/apply.js","../src/diffDOM/dom/undo.js","../src/diffDOM/virtual/helpers.js","../src/diffDOM/virtual/apply.js","../src/diffDOM/virtual/fromDOM.js","../src/diffDOM/virtual/fromString.js","../src/diffDOM/virtual/diff.js","../src/diffDOM/index.js","../src/TraceLogger.js"],"sourcesContent":["export function objToNode(objNode, insideSvg, options) {\r\n    let node\r\n    if (objNode.nodeName === '#text') {\r\n        node = options.document.createTextNode(objNode.data)\r\n\r\n    } else if (objNode.nodeName === '#comment') {\r\n        node = options.document.createComment(objNode.data)\r\n    } else {\r\n        if (objNode.nodeName === 'svg' || insideSvg) {\r\n            node = options.document.createElementNS('http://www.w3.org/2000/svg', objNode.nodeName)\r\n            insideSvg = true\r\n        } else if (options.caseSensitive) {\r\n            node = options.document.createElementNS(null, objNode.nodeName)\r\n        } else {\r\n            node = options.document.createElement(objNode.nodeName)\r\n        }\r\n        if (objNode.attributes) {\r\n            Object.entries(objNode.attributes).forEach(([key, value]) => node.setAttribute(key, value))\r\n        }\r\n        if (objNode.childNodes) {\r\n            objNode.childNodes.forEach(childNode => node.appendChild(objToNode(childNode, insideSvg, options)))\r\n        }\r\n        if (options.valueDiffing) {\r\n            if (objNode.value) {\r\n                node.value = objNode.value\r\n            }\r\n            if (objNode.checked) {\r\n                node.checked = objNode.checked\r\n            }\r\n            if (objNode.selected) {\r\n                node.selected = objNode.selected\r\n            }\r\n        }\r\n    }\r\n    return node\r\n}\r\n","import {objToNode} from \"./fromVirtual\"\r\n\r\n// ===== Apply a diff =====\r\n\r\nfunction getFromRoute(node, route) {\r\n    route = route.slice()\r\n    while (route.length > 0) {\r\n        if (!node.childNodes) {\r\n            return false\r\n        }\r\n        const c = route.splice(0, 1)[0]\r\n        node = node.childNodes[c]\r\n    }\r\n    return node\r\n}\r\n\r\nexport function applyDiff(\r\n        tree,\r\n        diff,\r\n        options // {preDiffApply, postDiffApply, textDiff, valueDiffing, _const}\r\n    ) {\r\n    let node = getFromRoute(tree, diff[options._const.route])\r\n    let newNode\r\n    let reference\r\n    let route\r\n    let nodeArray\r\n    let c\r\n\r\n    // pre-diff hook\r\n    const info = {\r\n        diff,\r\n        node\r\n    }\r\n\r\n    if (options.preDiffApply(info)) {\r\n        return true\r\n    }\r\n\r\n    switch (diff[options._const.action]) {\r\n        case options._const.addAttribute:\r\n            if (!node || !node.setAttribute) {\r\n                return false\r\n            }\r\n            node.setAttribute(diff[options._const.name], diff[options._const.value])\r\n            break\r\n        case options._const.modifyAttribute:\r\n            if (!node || !node.setAttribute) {\r\n                return false\r\n            }\r\n            node.setAttribute(diff[options._const.name], diff[options._const.newValue])\r\n            if (node.nodeName === 'INPUT' && diff[options._const.name] === 'value') {\r\n                node.value = diff[options._const.newValue]\r\n            }\r\n            break\r\n        case options._const.removeAttribute:\r\n            if (!node || !node.removeAttribute) {\r\n                return false\r\n            }\r\n            node.removeAttribute(diff[options._const.name])\r\n            break\r\n        case options._const.modifyTextElement:\r\n            if (!node || node.nodeType !== 3) {\r\n                return false\r\n            }\r\n            options.textDiff(node, node.data, diff[options._const.oldValue], diff[options._const.newValue])\r\n            break\r\n        case options._const.modifyValue:\r\n            if (!node || typeof node.value === 'undefined') {\r\n                return false\r\n            }\r\n            node.value = diff[options._const.newValue]\r\n            break\r\n        case options._const.modifyComment:\r\n            if (!node || typeof node.data === 'undefined') {\r\n                return false\r\n            }\r\n            options.textDiff(node, node.data, diff[options._const.oldValue], diff[options._const.newValue])\r\n            break\r\n        case options._const.modifyChecked:\r\n            if (!node || typeof node.checked === 'undefined') {\r\n                return false\r\n            }\r\n            node.checked = diff[options._const.newValue]\r\n            break\r\n        case options._const.modifySelected:\r\n            if (!node || typeof node.selected === 'undefined') {\r\n                return false\r\n            }\r\n            node.selected = diff[options._const.newValue]\r\n            break\r\n        case options._const.replaceElement:\r\n            node.parentNode.replaceChild(\r\n                objToNode(\r\n                    diff[options._const.newValue],\r\n                    node.namespaceURI === 'http://www.w3.org/2000/svg',\r\n                    options\r\n                ),\r\n                node\r\n            )\r\n            break\r\n        case options._const.relocateGroup:\r\n            nodeArray = Array(...new Array(diff.groupLength)).map(() => node.removeChild(node.childNodes[diff[options._const.from]]))\r\n            nodeArray.forEach((childNode, index) => {\r\n                if (index === 0) {\r\n                    reference = node.childNodes[diff[options._const.to]]\r\n                }\r\n                node.insertBefore(childNode, reference || null)\r\n            })\r\n            break\r\n        case options._const.removeElement:\r\n            node.parentNode.removeChild(node)\r\n            break\r\n        case options._const.addElement:\r\n            route = diff[options._const.route].slice()\r\n            c = route.splice(route.length - 1, 1)[0]\r\n            node = getFromRoute(tree, route)\r\n            node.insertBefore(\r\n                objToNode(\r\n                    diff[options._const.element],\r\n                    node.namespaceURI === 'http://www.w3.org/2000/svg',\r\n                    options\r\n                ),\r\n                node.childNodes[c] || null\r\n            )\r\n            break\r\n        case options._const.removeTextElement:\r\n            if (!node || node.nodeType !== 3) {\r\n                return false\r\n            }\r\n            node.parentNode.removeChild(node)\r\n            break\r\n        case options._const.addTextElement:\r\n            route = diff[options._const.route].slice()\r\n            c = route.splice(route.length - 1, 1)[0]\r\n            newNode = options.document.createTextNode(diff[options._const.value])\r\n            node = getFromRoute(tree, route)\r\n            if (!node || !node.childNodes) {\r\n                return false\r\n            }\r\n            node.insertBefore(newNode, node.childNodes[c] || null)\r\n            break\r\n        default:\r\n            console.log('unknown action')\r\n    }\r\n\r\n    // if a new node was created, we might be interested in its\r\n    // post diff hook\r\n    info.newNode = newNode\r\n    options.postDiffApply(info)\r\n\r\n    return true\r\n}\r\n\r\nexport function applyDOM(tree, diffs, options) {\r\n    return diffs.every(diff => applyDiff(tree, diff, options))\r\n}\r\n","import {applyDiff} from \"./apply\"\r\n\r\n// ===== Undo a diff =====\r\n\r\nfunction swap(obj, p1, p2) {\r\n    const tmp = obj[p1]\r\n    obj[p1] = obj[p2]\r\n    obj[p2] = tmp\r\n}\r\n\r\nfunction undoDiff(\r\n    tree,\r\n    diff,\r\n    options // {preDiffApply, postDiffApply, textDiff, valueDiffing, _const}\r\n) {\r\n\r\n    switch (diff[options._const.action]) {\r\n        case options._const.addAttribute:\r\n            diff[options._const.action] = options._const.removeAttribute\r\n            applyDiff(tree, diff, options)\r\n            break\r\n        case options._const.modifyAttribute:\r\n            swap(diff, options._const.oldValue, options._const.newValue)\r\n            applyDiff(tree, diff, options)\r\n            break\r\n        case options._const.removeAttribute:\r\n            diff[options._const.action] = options._const.addAttribute\r\n            applyDiff(tree, diff, options)\r\n            break\r\n        case options._const.modifyTextElement:\r\n            swap(diff, options._const.oldValue, options._const.newValue)\r\n            applyDiff(tree, diff, options)\r\n            break\r\n        case options._const.modifyValue:\r\n            swap(diff, options._const.oldValue, options._const.newValue)\r\n            applyDiff(tree, diff, options)\r\n            break\r\n        case options._const.modifyComment:\r\n            swap(diff, options._const.oldValue, options._const.newValue)\r\n            applyDiff(tree, diff, options)\r\n            break\r\n        case options._const.modifyChecked:\r\n            swap(diff, options._const.oldValue, options._const.newValue)\r\n            applyDiff(tree, diff, options)\r\n            break\r\n        case options._const.modifySelected:\r\n            swap(diff, options._const.oldValue, options._const.newValue)\r\n            applyDiff(tree, diff, options)\r\n            break\r\n        case options._const.replaceElement:\r\n            swap(diff, options._const.oldValue, options._const.newValue)\r\n            applyDiff(tree, diff, options)\r\n            break\r\n        case options._const.relocateGroup:\r\n            swap(diff, options._const.from, options._const.to)\r\n            applyDiff(tree, diff, options)\r\n            break\r\n        case options._const.removeElement:\r\n            diff[options._const.action] = options._const.addElement\r\n            applyDiff(tree, diff, options)\r\n            break\r\n        case options._const.addElement:\r\n            diff[options._const.action] = options._const.removeElement\r\n            applyDiff(tree, diff, options)\r\n            break\r\n        case options._const.removeTextElement:\r\n            diff[options._const.action] = options._const.addTextElement\r\n            applyDiff(tree, diff, options)\r\n            break\r\n        case options._const.addTextElement:\r\n            diff[options._const.action] = options._const.removeTextElement\r\n            applyDiff(tree, diff, options)\r\n            break\r\n        default:\r\n            console.log('unknown action')\r\n    }\r\n\r\n}\r\n\r\nexport function undoDOM(tree, diffs, options) {\r\n    if (!diffs.length) {\r\n        diffs = [diffs]\r\n    }\r\n    diffs = diffs.slice()\r\n    diffs.reverse()\r\n    diffs.forEach(diff => {\r\n        undoDiff(tree, diff, options)\r\n    })\r\n}\r\n","export class Diff {\r\n    constructor(options = {}) {\r\n        Object.entries(options).forEach(([key, value]) => this[key] = value)\r\n    }\r\n\r\n    toString() {\r\n        return JSON.stringify(this)\r\n    }\r\n\r\n    setValue(aKey, aValue) {\r\n        this[aKey] = aValue\r\n        return this\r\n    }\r\n}\r\n\r\nfunction elementDescriptors(el) {\r\n    const output = []\r\n    if (el.nodeName !== '#text' && el.nodeName !== '#comment') {\r\n        output.push(el.nodeName)\r\n        if (el.attributes) {\r\n            if (el.attributes['class']) {\r\n                output.push(`${el.nodeName}.${el.attributes['class'].replace(/ /g, '.')}`)\r\n            }\r\n            if (el.attributes.id) {\r\n                output.push(`${el.nodeName}#${el.attributes.id}`)\r\n            }\r\n        }\r\n\r\n    }\r\n    return output\r\n}\r\n\r\nfunction findUniqueDescriptors(li) {\r\n    const uniqueDescriptors = {}\r\n    const duplicateDescriptors = {}\r\n\r\n    li.forEach(node => {\r\n        elementDescriptors(node).forEach(descriptor => {\r\n            const inUnique = descriptor in uniqueDescriptors\r\n            const inDupes = descriptor in duplicateDescriptors\r\n            if (!inUnique && !inDupes) {\r\n                uniqueDescriptors[descriptor] = true\r\n            } else if (inUnique) {\r\n                delete uniqueDescriptors[descriptor]\r\n                duplicateDescriptors[descriptor] = true\r\n            }\r\n        })\r\n    })\r\n\r\n    return uniqueDescriptors\r\n}\r\n\r\nfunction uniqueInBoth(l1, l2) {\r\n    const l1Unique = findUniqueDescriptors(l1)\r\n    const l2Unique = findUniqueDescriptors(l2)\r\n    const inBoth = {}\r\n\r\n    Object.keys(l1Unique).forEach(key => {\r\n        if (l2Unique[key]) {\r\n            inBoth[key] = true\r\n        }\r\n    })\r\n\r\n    return inBoth\r\n}\r\n\r\nexport function removeDone(tree) {\r\n    delete tree.outerDone\r\n    delete tree.innerDone\r\n    delete tree.valueDone\r\n    if (tree.childNodes) {\r\n        return tree.childNodes.every(removeDone)\r\n    } else {\r\n        return true\r\n    }\r\n}\r\n\r\nexport function isEqual(e1, e2) {\r\n    if (!['nodeName', 'value', 'checked', 'selected', 'data'].every(element => {\r\n            if (e1[element] !== e2[element]) {\r\n                return false\r\n            }\r\n            return true\r\n        })) {\r\n        return false\r\n    }\r\n\r\n    if (Boolean(e1.attributes) !== Boolean(e2.attributes)) {\r\n        return false\r\n    }\r\n\r\n    if (Boolean(e1.childNodes) !== Boolean(e2.childNodes)) {\r\n        return false\r\n    }\r\n    if (e1.attributes) {\r\n        const e1Attributes = Object.keys(e1.attributes)\r\n        const e2Attributes = Object.keys(e2.attributes)\r\n\r\n        if (e1Attributes.length !== e2Attributes.length) {\r\n            return false\r\n        }\r\n        if (!e1Attributes.every(attribute => {\r\n                if (e1.attributes[attribute] !== e2.attributes[attribute]) {\r\n                    return false\r\n                }\r\n                return true\r\n            })) {\r\n            return false\r\n        }\r\n    }\r\n    if (e1.childNodes) {\r\n        if (e1.childNodes.length !== e2.childNodes.length) {\r\n            return false\r\n        }\r\n        if (!e1.childNodes.every((childNode, index) => isEqual(childNode, e2.childNodes[index]))) {\r\n\r\n            return false\r\n        }\r\n\r\n    }\r\n\r\n    return true\r\n}\r\n\r\n\r\nexport function roughlyEqual(e1, e2, uniqueDescriptors, sameSiblings, preventRecursion) {\r\n\r\n    if (!e1 || !e2) {\r\n        return false\r\n    }\r\n\r\n    if (e1.nodeName !== e2.nodeName) {\r\n        return false\r\n    }\r\n\r\n    if (e1.nodeName === '#text') {\r\n        // Note that we initially don't care what the text content of a node is,\r\n        // the mere fact that it's the same tag and \"has text\" means it's roughly\r\n        // equal, and then we can find out the true text difference later.\r\n        return preventRecursion ? true : e1.data === e2.data\r\n    }\r\n\r\n\r\n    if (e1.nodeName in uniqueDescriptors) {\r\n        return true\r\n    }\r\n\r\n    if (e1.attributes && e2.attributes) {\r\n\r\n        if (e1.attributes.id) {\r\n            if (e1.attributes.id !== e2.attributes.id) {\r\n                return false\r\n            } else {\r\n                const idDescriptor = `${e1.nodeName}#${e1.attributes.id}`\r\n                if (idDescriptor in uniqueDescriptors) {\r\n                    return true\r\n                }\r\n            }\r\n        }\r\n        if (e1.attributes['class'] && e1.attributes['class'] === e2.attributes['class']) {\r\n            const classDescriptor = `${e1.nodeName}.${e1.attributes['class'].replace(/ /g, '.')}`\r\n            if (classDescriptor in uniqueDescriptors) {\r\n                return true\r\n            }\r\n        }\r\n    }\r\n\r\n    if (sameSiblings) {\r\n        return true\r\n    }\r\n\r\n    const nodeList1 = e1.childNodes ? e1.childNodes.slice().reverse() : []\r\n    const nodeList2 = e2.childNodes ? e2.childNodes.slice().reverse() : []\r\n\r\n    if (nodeList1.length !== nodeList2.length) {\r\n        return false\r\n    }\r\n\r\n    if (preventRecursion) {\r\n        return nodeList1.every((element, index) => element.nodeName === nodeList2[index].nodeName)\r\n    } else {\r\n        // note: we only allow one level of recursion at any depth. If 'preventRecursion'\r\n        // was not set, we must explicitly force it to true for child iterations.\r\n        const childUniqueDescriptors = uniqueInBoth(nodeList1, nodeList2)\r\n        return nodeList1.every((element, index) => roughlyEqual(element, nodeList2[index], childUniqueDescriptors, true, true))\r\n    }\r\n}\r\n\r\n\r\nexport function cloneObj(obj) { //  TODO: Do we really need to clone here? Is it not enough to just return the original object?\r\n    return JSON.parse(JSON.stringify(obj))\r\n}\r\n/**\r\n * based on https://en.wikibooks.org/wiki/Algorithm_implementation/Strings/Longest_common_substring#JavaScript\r\n */\r\nfunction findCommonSubsets(c1, c2, marked1, marked2) {\r\n    let lcsSize = 0\r\n    let index = []\r\n    const c1Length = c1.length\r\n    const c2Length = c2.length\r\n\r\n    const // set up the matching table\r\n        matches = Array(...new Array(c1Length + 1)).map(() => [])\r\n\r\n    const uniqueDescriptors = uniqueInBoth(c1, c2)\r\n\r\n    let // If all of the elements are the same tag, id and class, then we can\r\n        // consider them roughly the same even if they have a different number of\r\n        // children. This will reduce removing and re-adding similar elements.\r\n        subsetsSame = c1Length === c2Length\r\n\r\n    if (subsetsSame) {\r\n\r\n        c1.some((element, i) => {\r\n            const c1Desc = elementDescriptors(element)\r\n            const c2Desc = elementDescriptors(c2[i])\r\n            if (c1Desc.length !== c2Desc.length) {\r\n                subsetsSame = false\r\n                return true\r\n            }\r\n            c1Desc.some((description, i) => {\r\n                if (description !== c2Desc[i]) {\r\n                    subsetsSame = false\r\n                    return true\r\n                }\r\n            })\r\n            if (!subsetsSame) {\r\n                return true\r\n            }\r\n        })\r\n    }\r\n\r\n    // fill the matches with distance values\r\n    for (let c1Index = 0; c1Index < c1Length; c1Index++) {\r\n        const c1Element = c1[c1Index]\r\n        for (let c2Index = 0; c2Index < c2Length; c2Index++) {\r\n            const c2Element = c2[c2Index]\r\n            if (!marked1[c1Index] && !marked2[c2Index] && roughlyEqual(c1Element, c2Element, uniqueDescriptors, subsetsSame)) {\r\n                matches[c1Index + 1][c2Index + 1] = (matches[c1Index][c2Index] ? matches[c1Index][c2Index] + 1 : 1)\r\n                if (matches[c1Index + 1][c2Index + 1] >= lcsSize) {\r\n                    lcsSize = matches[c1Index + 1][c2Index + 1]\r\n                    index = [c1Index + 1, c2Index + 1]\r\n                }\r\n            } else {\r\n                matches[c1Index + 1][c2Index + 1] = 0\r\n            }\r\n        }\r\n    }\r\n\r\n    if (lcsSize === 0) {\r\n        return false\r\n    }\r\n\r\n    return {\r\n        oldValue: index[0] - lcsSize,\r\n        newValue: index[1] - lcsSize,\r\n        length: lcsSize\r\n    }\r\n}\r\n\r\n/**\r\n * This should really be a predefined function in Array...\r\n */\r\nfunction makeArray(n, v) {\r\n    return Array(...new Array(n)).map(() => v)\r\n}\r\n\r\n/**\r\n * Generate arrays that indicate which node belongs to which subset,\r\n * or whether it's actually an orphan node, existing in only one\r\n * of the two trees, rather than somewhere in both.\r\n *\r\n * So if t1 = <img><canvas><br>, t2 = <canvas><br><img>.\r\n * The longest subset is \"<canvas><br>\" (length 2), so it will group 0.\r\n * The second longest is \"<img>\" (length 1), so it will be group 1.\r\n * gaps1 will therefore be [1,0,0] and gaps2 [0,0,1].\r\n *\r\n * If an element is not part of any group, it will stay being 'true', which\r\n * is the initial value. For example:\r\n * t1 = <img><p></p><br><canvas>, t2 = <b></b><br><canvas><img>\r\n *\r\n * The \"<p></p>\" and \"<b></b>\" do only show up in one of the two and will\r\n * therefore be marked by \"true\". The remaining parts are parts of the\r\n * groups 0 and 1:\r\n * gaps1 = [1, true, 0, 0], gaps2 = [true, 0, 0, 1]\r\n *\r\n */\r\nexport function getGapInformation(t1, t2, stable) {\r\n    const gaps1 = t1.childNodes ? makeArray(t1.childNodes.length, true) : []\r\n    const gaps2 = t2.childNodes ? makeArray(t2.childNodes.length, true) : []\r\n    let group = 0\r\n\r\n    // give elements from the same subset the same group number\r\n    stable.forEach(subset => {\r\n        const endOld = subset.oldValue + subset.length\r\n        const endNew = subset.newValue + subset.length\r\n\r\n        for (let j = subset.oldValue; j < endOld; j += 1) {\r\n            gaps1[j] = group\r\n        }\r\n        for (let j = subset.newValue; j < endNew; j += 1) {\r\n            gaps2[j] = group\r\n        }\r\n        group += 1\r\n    })\r\n\r\n    return {\r\n        gaps1,\r\n        gaps2\r\n    }\r\n}\r\n\r\n/**\r\n * Find all matching subsets, based on immediate child differences only.\r\n */\r\nexport function markSubTrees(oldTree, newTree) {\r\n    // note: the child lists are views, and so update as we update old/newTree\r\n    const oldChildren = oldTree.childNodes ? oldTree.childNodes : []\r\n\r\n    const newChildren = newTree.childNodes ? newTree.childNodes : []\r\n    const marked1 = makeArray(oldChildren.length, false)\r\n    const marked2 = makeArray(newChildren.length, false)\r\n    const subsets = []\r\n    let subset = true\r\n\r\n    const returnIndex = function() {\r\n        return arguments[1]\r\n    }\r\n\r\n    const markBoth = i => {\r\n        marked1[subset.oldValue + i] = true\r\n        marked2[subset.newValue + i] = true\r\n    }\r\n\r\n    while (subset) {\r\n        subset = findCommonSubsets(oldChildren, newChildren, marked1, marked2)\r\n        if (subset) {\r\n            subsets.push(subset)\r\n            const subsetArray = Array(...new Array(subset.length)).map(returnIndex)\r\n            subsetArray.forEach(item => markBoth(item))\r\n        }\r\n    }\r\n\r\n    oldTree.subsets = subsets\r\n    oldTree.subsetsAge = 100\r\n    return subsets\r\n}\r\n\r\nexport class DiffTracker {\r\n    constructor() {\r\n        this.list = []\r\n    }\r\n\r\n    add(diffs) {\r\n        this.list.push(...diffs)\r\n    }\r\n    forEach(fn) {\r\n        this.list.forEach(li => fn(li))\r\n    }\r\n\r\n}\r\n","import {cloneObj} from \"./helpers\"\r\n\r\n// ===== Apply a virtual diff =====\r\n\r\nfunction getFromVirtualRoute(tree, route) {\r\n    let node = tree\r\n    let parentNode\r\n    let nodeIndex\r\n\r\n    route = route.slice()\r\n    while (route.length > 0) {\r\n        if (!node.childNodes) {\r\n            return false\r\n        }\r\n        nodeIndex = route.splice(0, 1)[0]\r\n        parentNode = node\r\n        node = node.childNodes[nodeIndex]\r\n    }\r\n    return {\r\n        node,\r\n        parentNode,\r\n        nodeIndex\r\n    }\r\n}\r\n\r\nfunction applyVirtualDiff(\r\n        tree,\r\n        diff,\r\n        options // {preDiffApply, postDiffApply, _const}\r\n    ) {\r\n    const routeInfo = getFromVirtualRoute(tree, diff[options._const.route])\r\n    let node = routeInfo.node\r\n    const parentNode = routeInfo.parentNode\r\n    const nodeIndex = routeInfo.nodeIndex\r\n    const newSubsets = []\r\n\r\n    // pre-diff hook\r\n    const info = {\r\n        diff,\r\n        node\r\n    }\r\n\r\n    if (options.preDiffApply(info)) {\r\n        return true\r\n    }\r\n\r\n    let newNode\r\n    let nodeArray\r\n    let route\r\n    let c\r\n    switch (diff[options._const.action]) {\r\n        case options._const.addAttribute:\r\n            if (!node.attributes) {\r\n                node.attributes = {}\r\n            }\r\n\r\n            node.attributes[diff[options._const.name]] = diff[options._const.value]\r\n\r\n            if (diff[options._const.name] === 'checked') {\r\n                node.checked = true\r\n            } else if (diff[options._const.name] === 'selected') {\r\n                node.selected = true\r\n            } else if (node.nodeName === 'INPUT' && diff[options._const.name] === 'value') {\r\n                node.value = diff[options._const.value]\r\n            }\r\n\r\n            break\r\n        case options._const.modifyAttribute:\r\n            node.attributes[diff[options._const.name]] = diff[options._const.newValue]\r\n            break\r\n        case options._const.removeAttribute:\r\n\r\n            delete node.attributes[diff[options._const.name]]\r\n\r\n            if (Object.keys(node.attributes).length === 0) {\r\n                delete node.attributes\r\n            }\r\n\r\n            if (diff[options._const.name] === 'checked') {\r\n                node.checked = false\r\n            } else if (diff[options._const.name] === 'selected') {\r\n                delete node.selected\r\n            } else if (node.nodeName === 'INPUT' && diff[options._const.name] === 'value') {\r\n                delete node.value\r\n            }\r\n\r\n            break\r\n        case options._const.modifyTextElement:\r\n            node.data = diff[options._const.newValue]\r\n            break\r\n        case options._const.modifyValue:\r\n            node.value = diff[options._const.newValue]\r\n            break\r\n        case options._const.modifyComment:\r\n            node.data = diff[options._const.newValue]\r\n            break\r\n        case options._const.modifyChecked:\r\n            node.checked = diff[options._const.newValue]\r\n            break\r\n        case options._const.modifySelected:\r\n            node.selected = diff[options._const.newValue]\r\n            break\r\n        case options._const.replaceElement:\r\n            newNode = cloneObj(diff[options._const.newValue])\r\n            newNode.outerDone = true\r\n            newNode.innerDone = true\r\n            newNode.valueDone = true\r\n            parentNode.childNodes[nodeIndex] = newNode\r\n            break\r\n        case options._const.relocateGroup:\r\n            nodeArray = node.childNodes.splice(diff[options._const.from], diff.groupLength).reverse()\r\n            nodeArray.forEach(movedNode => node.childNodes.splice(diff[options._const.to], 0, movedNode))\r\n            if (node.subsets) {\r\n                node.subsets.forEach(map => {\r\n                    if (diff[options._const.from] < diff[options._const.to] && map.oldValue <= diff[options._const.to] && map.oldValue > diff[options._const.from]) {\r\n                        map.oldValue -= diff.groupLength\r\n                        const splitLength = map.oldValue + map.length - diff[options._const.to]\r\n                        if (splitLength > 0) {\r\n                            // new insertion splits map.\r\n                            newSubsets.push({\r\n                                oldValue: diff[options._const.to] + diff.groupLength,\r\n                                newValue: map.newValue + map.length - splitLength,\r\n                                length: splitLength\r\n                            })\r\n                            map.length -= splitLength\r\n                        }\r\n                    } else if (diff[options._const.from] > diff[options._const.to] && map.oldValue > diff[options._const.to] && map.oldValue < diff[options._const.from]) {\r\n                        map.oldValue += diff.groupLength\r\n                        const splitLength = map.oldValue + map.length - diff[options._const.to]\r\n                        if (splitLength > 0) {\r\n                            // new insertion splits map.\r\n                            newSubsets.push({\r\n                                oldValue: diff[options._const.to] + diff.groupLength,\r\n                                newValue: map.newValue + map.length - splitLength,\r\n                                length: splitLength\r\n                            })\r\n                            map.length -= splitLength\r\n                        }\r\n                    } else if (map.oldValue === diff[options._const.from]) {\r\n                        map.oldValue = diff[options._const.to]\r\n                    }\r\n                })\r\n            }\r\n\r\n            break\r\n        case options._const.removeElement:\r\n            parentNode.childNodes.splice(nodeIndex, 1)\r\n            if (parentNode.subsets) {\r\n                parentNode.subsets.forEach(map => {\r\n                    if (map.oldValue > nodeIndex) {\r\n                        map.oldValue -= 1\r\n                    } else if (map.oldValue === nodeIndex) {\r\n                        map.delete = true\r\n                    } else if (map.oldValue < nodeIndex && (map.oldValue + map.length) > nodeIndex) {\r\n                        if (map.oldValue + map.length - 1 === nodeIndex) {\r\n                            map.length--\r\n                        } else {\r\n                            newSubsets.push({\r\n                                newValue: map.newValue + nodeIndex - map.oldValue,\r\n                                oldValue: nodeIndex,\r\n                                length: map.length - nodeIndex + map.oldValue - 1\r\n                            })\r\n                            map.length = nodeIndex - map.oldValue\r\n                        }\r\n                    }\r\n                })\r\n            }\r\n            node = parentNode\r\n            break\r\n        case options._const.addElement:\r\n            route = diff[options._const.route].slice()\r\n            c = route.splice(route.length - 1, 1)[0]\r\n            node = getFromVirtualRoute(tree, route).node\r\n            newNode = cloneObj(diff[options._const.element])\r\n            newNode.outerDone = true\r\n            newNode.innerDone = true\r\n            newNode.valueDone = true\r\n\r\n            if (!node.childNodes) {\r\n                node.childNodes = []\r\n            }\r\n\r\n            if (c >= node.childNodes.length) {\r\n                node.childNodes.push(newNode)\r\n            } else {\r\n                node.childNodes.splice(c, 0, newNode)\r\n            }\r\n            if (node.subsets) {\r\n                node.subsets.forEach(map => {\r\n                    if (map.oldValue >= c) {\r\n                        map.oldValue += 1\r\n                    } else if (map.oldValue < c && (map.oldValue + map.length) > c) {\r\n                        const splitLength = map.oldValue + map.length - c\r\n                        newSubsets.push({\r\n                            newValue: map.newValue + map.length - splitLength,\r\n                            oldValue: c + 1,\r\n                            length: splitLength\r\n                        })\r\n                        map.length -= splitLength\r\n                    }\r\n                })\r\n            }\r\n            break\r\n        case options._const.removeTextElement:\r\n            parentNode.childNodes.splice(nodeIndex, 1)\r\n            if (parentNode.nodeName === 'TEXTAREA') {\r\n                delete parentNode.value\r\n            }\r\n            if (parentNode.subsets) {\r\n                parentNode.subsets.forEach(map => {\r\n                    if (map.oldValue > nodeIndex) {\r\n                        map.oldValue -= 1\r\n                    } else if (map.oldValue === nodeIndex) {\r\n                        map.delete = true\r\n                    } else if (map.oldValue < nodeIndex && (map.oldValue + map.length) > nodeIndex) {\r\n                        if (map.oldValue + map.length - 1 === nodeIndex) {\r\n                            map.length--\r\n                        } else {\r\n                            newSubsets.push({\r\n                                newValue: map.newValue + nodeIndex - map.oldValue,\r\n                                oldValue: nodeIndex,\r\n                                length: map.length - nodeIndex + map.oldValue - 1\r\n                            })\r\n                            map.length = nodeIndex - map.oldValue\r\n                        }\r\n                    }\r\n                })\r\n            }\r\n            node = parentNode\r\n            break\r\n        case options._const.addTextElement:\r\n            route = diff[options._const.route].slice()\r\n            c = route.splice(route.length - 1, 1)[0]\r\n            newNode = {}\r\n            newNode.nodeName = '#text'\r\n            newNode.data = diff[options._const.value]\r\n            node = getFromVirtualRoute(tree, route).node\r\n            if (!node.childNodes) {\r\n                node.childNodes = []\r\n            }\r\n\r\n            if (c >= node.childNodes.length) {\r\n                node.childNodes.push(newNode)\r\n            } else {\r\n                node.childNodes.splice(c, 0, newNode)\r\n            }\r\n            if (node.nodeName === 'TEXTAREA') {\r\n                node.value = diff[options._const.newValue]\r\n            }\r\n            if (node.subsets) {\r\n                node.subsets.forEach(map => {\r\n                    if (map.oldValue >= c) {\r\n                        map.oldValue += 1\r\n                    }\r\n                    if (map.oldValue < c && (map.oldValue + map.length) > c) {\r\n                        const splitLength = map.oldValue + map.length - c\r\n                        newSubsets.push({\r\n                            newValue: map.newValue + map.length - splitLength,\r\n                            oldValue: c + 1,\r\n                            length: splitLength\r\n                        })\r\n                        map.length -= splitLength\r\n                    }\r\n                })\r\n            }\r\n            break\r\n        default:\r\n            console.log('unknown action')\r\n    }\r\n\r\n    if (node.subsets) {\r\n        node.subsets = node.subsets.filter(map => !map.delete && map.oldValue !== map.newValue)\r\n        if (newSubsets.length) {\r\n            node.subsets = node.subsets.concat(newSubsets)\r\n        }\r\n    }\r\n\r\n    // capture newNode for the callback\r\n    info.newNode = newNode\r\n    options.postDiffApply(info)\r\n\r\n    return\r\n}\r\n\r\nexport function applyVirtual(tree, diffs, options) {\r\n    diffs.forEach(diff => {\r\n        applyVirtualDiff(tree, diff, options)\r\n    })\r\n    return true\r\n}\r\n","export function nodeToObj(aNode, options = {}) {\r\n    const objNode = {}\r\n    objNode.nodeName = aNode.nodeName\r\n    if (objNode.nodeName === '#text' || objNode.nodeName === '#comment') {\r\n        objNode.data = aNode.data\r\n    } else {\r\n        if (aNode.attributes && aNode.attributes.length > 0) {\r\n            objNode.attributes = {}\r\n            const nodeArray = Array.prototype.slice.call(aNode.attributes)\r\n            nodeArray.forEach(attribute => objNode.attributes[attribute.name] = attribute.value)\r\n        }\r\n        if (objNode.nodeName === 'TEXTAREA') {\r\n            objNode.value = aNode.value\r\n        } else if (aNode.childNodes && aNode.childNodes.length > 0) {\r\n            objNode.childNodes = []\r\n            const nodeArray = Array.prototype.slice.call(aNode.childNodes)\r\n            nodeArray.forEach(childNode => objNode.childNodes.push(nodeToObj(childNode, options)))\r\n        }\r\n        if (options.valueDiffing) {\r\n            if (aNode.checked !== undefined && aNode.type && ['radio', 'checkbox'].includes(aNode.type.toLowerCase())) {\r\n                objNode.checked = aNode.checked\r\n            } else if (aNode.value !== undefined) {\r\n                objNode.value = aNode.value\r\n            }\r\n            if (aNode.selected !== undefined) {\r\n                objNode.selected = aNode.selected\r\n            }\r\n        }\r\n    }\r\n    return objNode\r\n}\r\n","// from html-parse-stringify (MIT)\r\n\r\nconst tagRE = /<(?:\"[^\"]*\"['\"]*|'[^']*'['\"]*|[^'\">])+>/g\r\n// re-used obj for quick lookups of components\r\nconst empty = Object.create ? Object.create(null) : {}\r\nconst attrRE = /([\\w-:]+)|(['\"])([^'\"]*)\\2/g\r\n\r\n// create optimized lookup object for\r\n// void elements as listed here:\r\n// http://www.w3.org/html/wg/drafts/html/master/syntax.html#void-elements\r\nconst lookup = {\r\n    area: true,\r\n    base: true,\r\n    br: true,\r\n    col: true,\r\n    embed: true,\r\n    hr: true,\r\n    img: true,\r\n    input: true,\r\n    keygen: true,\r\n    link: true,\r\n    menuItem: true,\r\n    meta: true,\r\n    param: true,\r\n    source: true,\r\n    track: true,\r\n    wbr: true\r\n}\r\n\r\nfunction parseTag(tag) {\r\n    let i = 0\r\n    let key\r\n    const res = {\r\n        nodeName: ''\r\n    }\r\n\r\n    tag.replace(attrRE, match => {\r\n        if (i % 2) {\r\n            key = match\r\n        } else if (i === 0) {\r\n                if (lookup[match] || tag.charAt(tag.length - 2) === '/') {\r\n                    res.voidElement = true\r\n                }\r\n                res.nodeName = match.toUpperCase()\r\n            } else {\r\n                if (!res.attributes) {\r\n                    res.attributes = {}\r\n                }\r\n                res.attributes[key] = match.replace(/^['\"]|['\"]$/g, '')\r\n            }\r\n        i++\r\n    })\r\n\r\n    return res\r\n}\r\n\r\n\r\nfunction parse(\r\n    html,\r\n    options = {components: empty}\r\n) {\r\n    const result = []\r\n    let current\r\n    let level = -1\r\n    const arr = []\r\n    const byTag = {}\r\n    let inComponent = false\r\n\r\n    html.replace(tagRE, (tag, index) => {\r\n        if (inComponent) {\r\n            if (tag !== (`</${current.nodeName}>`)) {\r\n                return\r\n            } else {\r\n                inComponent = false\r\n            }\r\n        }\r\n        const isOpen = tag.charAt(1) !== '/'\r\n        const start = index + tag.length\r\n        const nextChar = html.charAt(start)\r\n        let parent\r\n\r\n        if (isOpen) {\r\n            level++\r\n\r\n            current = parseTag(tag)\r\n            if (current.type === 'tag' && options.components[current.nodeName]) {\r\n                current.type = 'component'\r\n                inComponent = true\r\n            }\r\n\r\n            if (!current.voidElement && !inComponent && nextChar && nextChar !== '<') {\r\n                if (!current.childNodes) {\r\n                    current.childNodes = []\r\n                }\r\n                current.childNodes.push({\r\n                    nodeName: '#text',\r\n                    data: html.slice(start, html.indexOf('<', start))\r\n                })\r\n            }\r\n\r\n            byTag[current.tagName] = current\r\n\r\n            // if we're at root, push new base node\r\n            if (level === 0) {\r\n                result.push(current)\r\n            }\r\n\r\n            parent = arr[level - 1]\r\n\r\n            if (parent) {\r\n                if (!parent.childNodes) {\r\n                    parent.childNodes = []\r\n                }\r\n                parent.childNodes.push(current)\r\n            }\r\n\r\n            arr[level] = current\r\n        }\r\n\r\n        if (!isOpen || current.voidElement) {\r\n            level--\r\n            if (!inComponent && nextChar !== '<' && nextChar) {\r\n                // trailing text node\r\n                // if we're at the root, push a base text node. otherwise add as\r\n                // a child to the current node.\r\n                parent = level === -1 ? result : arr[level].childNodes || []\r\n\r\n                // calculate correct end of the data slice in case there's\r\n                // no tag after the text node.\r\n                const end = html.indexOf('<', start)\r\n                const data = html.slice(start, end === -1 ? undefined : end)\r\n                parent.push({\r\n                    nodeName: '#text',\r\n                    data\r\n                })\r\n            }\r\n        }\r\n    })\r\n\r\n    return result[0]\r\n}\r\n\r\nfunction cleanObj(obj) {\r\n    delete obj.voidElement\r\n    if (obj.childNodes) {\r\n        obj.childNodes.forEach(child => cleanObj(child))\r\n    }\r\n    return obj\r\n}\r\n\r\nexport function stringToObj(string) {\r\n   return cleanObj(parse(string))\r\n}\r\n","import {Diff, DiffTracker, cloneObj, getGapInformation, isEqual, markSubTrees, removeDone, roughlyEqual} from \"./helpers\"\r\nimport {applyVirtual} from \"./apply\"\r\nimport {nodeToObj} from \"./fromDOM\"\r\nimport {stringToObj} from \"./fromString\"\r\n\r\n// ===== Create a diff =====\r\n\r\nexport class DiffFinder {\r\n    constructor(t1Node, t2Node, options) {\r\n        this.options = options\r\n        this.t1 = (t1Node instanceof HTMLElement) ? nodeToObj(t1Node, this.options) : (typeof t1Node === 'string') ? stringToObj(t1Node, this.options) : JSON.parse(JSON.stringify(t1Node))\r\n        this.t2 = (t2Node instanceof HTMLElement) ? nodeToObj(t2Node, this.options) : (typeof t2Node === 'string') ? stringToObj(t2Node, this.options) : JSON.parse(JSON.stringify(t2Node))\r\n        this.diffcount = 0\r\n        this.foundAll = false\r\n        if (this.debug) {\r\n            this.t1Orig = nodeToObj(t1Node, this.options)\r\n            this.t2Orig = nodeToObj(t2Node, this.options)\r\n        }\r\n\r\n        this.tracker = new DiffTracker()\r\n    }\r\n\r\n    init() {\r\n        return this.findDiffs(this.t1, this.t2)\r\n    }\r\n\r\n    findDiffs(t1, t2) {\r\n        let diffs\r\n        do {\r\n            if (this.options.debug) {\r\n                this.diffcount += 1\r\n                if (this.diffcount > this.options.diffcap) {\r\n                    window.diffError = [this.t1Orig, this.t2Orig]\r\n                    throw new Error(`surpassed diffcap:${JSON.stringify(this.t1Orig)} -> ${JSON.stringify(this.t2Orig)}`)\r\n                }\r\n            }\r\n            diffs = this.findNextDiff(t1, t2, [])\r\n\r\n            if (diffs.length === 0) {\r\n                // Last check if the elements really are the same now.\r\n                // If not, remove all info about being done and start over.\r\n                // Sometimes a node can be marked as done, but the creation of subsequent diffs means that it has to be changed again.\r\n                if (!isEqual(t1, t2)) {\r\n                    if (this.foundAll) {\r\n                        console.error('Could not find remaining diffs!')\r\n                    } else {\r\n                        this.foundAll = true\r\n                        removeDone(t1)\r\n                        diffs = this.findNextDiff(t1, t2, [])\r\n                    }\r\n                }\r\n            }\r\n            if (diffs.length > 0) {\r\n                this.foundAll = false\r\n                this.tracker.add(diffs)\r\n                applyVirtual(t1, diffs, this.options)\r\n            }\r\n        } while (diffs.length > 0)\r\n\r\n        return this.tracker.list\r\n    }\r\n\r\n    findNextDiff(t1, t2, route) {\r\n        let diffs\r\n        let fdiffs\r\n\r\n        if (this.options.maxDepth && route.length > this.options.maxDepth) {\r\n            return []\r\n        }\r\n        // outer differences?\r\n        if (!t1.outerDone) {\r\n            diffs = this.findOuterDiff(t1, t2, route)\r\n            if (this.options.filterOuterDiff) {\r\n                fdiffs = this.options.filterOuterDiff(t1, t2, diffs)\r\n                if (fdiffs) diffs = fdiffs\r\n            }\r\n            if (diffs.length > 0) {\r\n                t1.outerDone = true\r\n                return diffs\r\n            } else {\r\n                t1.outerDone = true\r\n            }\r\n        }\r\n        // inner differences?\r\n        if (!t1.innerDone) {\r\n            diffs = this.findInnerDiff(t1, t2, route)\r\n            if (diffs.length > 0) {\r\n                return diffs\r\n            } else {\r\n                t1.innerDone = true\r\n            }\r\n        }\r\n\r\n        if (this.options.valueDiffing && !t1.valueDone) {\r\n            // value differences?\r\n            diffs = this.findValueDiff(t1, t2, route)\r\n\r\n            if (diffs.length > 0) {\r\n                t1.valueDone = true\r\n                return diffs\r\n            } else {\r\n                t1.valueDone = true\r\n            }\r\n        }\r\n\r\n        // no differences\r\n        return []\r\n    }\r\n\r\n    findOuterDiff(t1, t2, route) {\r\n        const diffs = []\r\n        let attr\r\n        let attr1\r\n        let attr2\r\n        let attrLength\r\n        let pos\r\n        let i\r\n        if (t1.nodeName !== t2.nodeName) {\r\n            if (!route.length) {\r\n                throw new Error('Top level nodes have to be of the same kind.')\r\n            }\r\n            return [new Diff()\r\n                .setValue(this.options._const.action, this.options._const.replaceElement)\r\n                .setValue(this.options._const.oldValue, cloneObj(t1))\r\n                .setValue(this.options._const.newValue, cloneObj(t2))\r\n                .setValue(this.options._const.route, route)\r\n            ]\r\n        }\r\n        if (route.length && this.options.maxNodeDiffCount < Math.abs((t1.childNodes || []).length - (t2.childNodes || []).length)) {\r\n            return [new Diff()\r\n                .setValue(this.options._const.action, this.options._const.replaceElement)\r\n                .setValue(this.options._const.oldValue, cloneObj(t1))\r\n                .setValue(this.options._const.newValue, cloneObj(t2))\r\n                .setValue(this.options._const.route, route)\r\n            ]\r\n        }\r\n\r\n        if (t1.data !== t2.data) {\r\n            // Comment or text node.\r\n            if (t1.nodeName === '#text') {\r\n                return [new Diff()\r\n                    .setValue(this.options._const.action, this.options._const.modifyTextElement)\r\n                    .setValue(this.options._const.route, route)\r\n                    .setValue(this.options._const.oldValue, t1.data)\r\n                    .setValue(this.options._const.newValue, t2.data)\r\n                ]\r\n            } else {\r\n                return [new Diff()\r\n                    .setValue(this.options._const.action, this.options._const.modifyComment)\r\n                    .setValue(this.options._const.route, route)\r\n                    .setValue(this.options._const.oldValue, t1.data)\r\n                    .setValue(this.options._const.newValue, t2.data)\r\n                ]\r\n            }\r\n\r\n        }\r\n\r\n        attr1 = t1.attributes ? Object.keys(t1.attributes).sort() : []\r\n        attr2 = t2.attributes ? Object.keys(t2.attributes).sort() : []\r\n\r\n        attrLength = attr1.length\r\n        for (i = 0; i < attrLength; i++) {\r\n            attr = attr1[i]\r\n            pos = attr2.indexOf(attr)\r\n            if (pos === -1) {\r\n                diffs.push(new Diff()\r\n                    .setValue(this.options._const.action, this.options._const.removeAttribute)\r\n                    .setValue(this.options._const.route, route)\r\n                    .setValue(this.options._const.name, attr)\r\n                    .setValue(this.options._const.value, t1.attributes[attr])\r\n                )\r\n            } else {\r\n                attr2.splice(pos, 1)\r\n                if (t1.attributes[attr] !== t2.attributes[attr]) {\r\n                    diffs.push(new Diff()\r\n                        .setValue(this.options._const.action, this.options._const.modifyAttribute)\r\n                        .setValue(this.options._const.route, route)\r\n                        .setValue(this.options._const.name, attr)\r\n                        .setValue(this.options._const.oldValue, t1.attributes[attr])\r\n                        .setValue(this.options._const.newValue, t2.attributes[attr])\r\n                    )\r\n                }\r\n            }\r\n        }\r\n\r\n        attrLength = attr2.length\r\n        for (i = 0; i < attrLength; i++) {\r\n            attr = attr2[i]\r\n            diffs.push(new Diff()\r\n                .setValue(this.options._const.action, this.options._const.addAttribute)\r\n                .setValue(this.options._const.route, route)\r\n                .setValue(this.options._const.name, attr)\r\n                .setValue(this.options._const.value, t2.attributes[attr])\r\n            )\r\n        }\r\n\r\n        return diffs\r\n    }\r\n\r\n    findInnerDiff(t1, t2, route) {\r\n        const t1ChildNodes = t1.childNodes ? t1.childNodes.slice() : []\r\n        const t2ChildNodes = t2.childNodes ? t2.childNodes.slice() : []\r\n        const last = Math.max(t1ChildNodes.length, t2ChildNodes.length)\r\n        let childNodesLengthDifference = Math.abs(t1ChildNodes.length - t2ChildNodes.length)\r\n        let diffs = []\r\n        let index = 0\r\n        if (!this.options.maxChildCount || last < this.options.maxChildCount) {\r\n            const subtrees = t1.subsets && t1.subsetsAge-- ? t1.subsets : (t1.childNodes && t2.childNodes) ? markSubTrees(t1, t2) : []\r\n\r\n            if (subtrees.length > 0) {\r\n                /* One or more groups have been identified among the childnodes of t1\r\n                 * and t2.\r\n                 */\r\n                diffs = this.attemptGroupRelocation(t1, t2, subtrees, route)\r\n                if (diffs.length > 0) {\r\n                    return diffs\r\n                }\r\n            }\r\n        }\r\n\r\n\r\n        /* 0 or 1 groups of similar child nodes have been found\r\n         * for t1 and t2. 1 If there is 1, it could be a sign that the\r\n         * contents are the same. When the number of groups is below 2,\r\n         * t1 and t2 are made to have the same length and each of the\r\n         * pairs of child nodes are diffed.\r\n         */\r\n\r\n        for (let i = 0; i < last; i += 1) {\r\n            const e1 = t1ChildNodes[i]\r\n            const e2 = t2ChildNodes[i]\r\n\r\n            if (childNodesLengthDifference) {\r\n                /* t1 and t2 have different amounts of childNodes. Add\r\n                 * and remove as necessary to obtain the same length */\r\n                if (e1 && !e2) {\r\n                    if (e1.nodeName === '#text') {\r\n                        diffs.push(new Diff()\r\n                            .setValue(this.options._const.action, this.options._const.removeTextElement)\r\n                            .setValue(this.options._const.route, route.concat(index))\r\n                            .setValue(this.options._const.value, e1.data)\r\n                        )\r\n                        index -= 1\r\n                    } else {\r\n                        diffs.push(new Diff()\r\n                            .setValue(this.options._const.action, this.options._const.removeElement)\r\n                            .setValue(this.options._const.route, route.concat(index))\r\n                            .setValue(this.options._const.element, cloneObj(e1))\r\n                        )\r\n                        index -= 1\r\n                    }\r\n\r\n                } else if (e2 && !e1) {\r\n                    if (e2.nodeName === '#text') {\r\n                        diffs.push(new Diff()\r\n                            .setValue(this.options._const.action, this.options._const.addTextElement)\r\n                            .setValue(this.options._const.route, route.concat(index))\r\n                            .setValue(this.options._const.value, e2.data)\r\n                        )\r\n                    } else {\r\n                        diffs.push(new Diff()\r\n                            .setValue(this.options._const.action, this.options._const.addElement)\r\n                            .setValue(this.options._const.route, route.concat(index))\r\n                            .setValue(this.options._const.element, cloneObj(e2))\r\n                        )\r\n                    }\r\n                }\r\n            }\r\n            /* We are now guaranteed that childNodes e1 and e2 exist,\r\n             * and that they can be diffed.\r\n             */\r\n            /* Diffs in child nodes should not affect the parent node,\r\n             * so we let these diffs be submitted together with other\r\n             * diffs.\r\n             */\r\n\r\n            if (e1 && e2) {\r\n                if (!this.options.maxChildCount || last < this.options.maxChildCount) {\r\n                    diffs = diffs.concat(this.findNextDiff(e1, e2, route.concat(index)))\r\n                } else if (!isEqual(e1, e2)) {\r\n                    if (t1ChildNodes.length > t2ChildNodes.length) {\r\n                        diffs = diffs.concat([\r\n                            new Diff()\r\n                                .setValue(this.options._const.action, this.options._const.removeElement)\r\n                                .setValue(this.options._const.element, cloneObj(e1))\r\n                                .setValue(this.options._const.route, route.concat(index))\r\n                        ])\r\n                        t1ChildNodes.splice(i, 1)\r\n                        index -= 1\r\n                        childNodesLengthDifference -= 1\r\n                    } else if (t1ChildNodes.length < t2ChildNodes.length) {\r\n                        diffs = diffs.concat([\r\n                            new Diff()\r\n                                .setValue(this.options._const.action, this.options._const.addElement)\r\n                                .setValue(this.options._const.element, cloneObj(e2))\r\n                                .setValue(this.options._const.route, route.concat(index))\r\n                        ])\r\n                        t1ChildNodes.splice(i, 0, {})\r\n                        childNodesLengthDifference -= 1\r\n                    } else {\r\n                        diffs = diffs.concat([\r\n                            new Diff()\r\n                                .setValue(this.options._const.action, this.options._const.replaceElement)\r\n                                .setValue(this.options._const.oldValue, cloneObj(e1))\r\n                                .setValue(this.options._const.newValue, cloneObj(e2))\r\n                                .setValue(this.options._const.route, route.concat(index))\r\n                        ])\r\n                    }\r\n\r\n                }\r\n\r\n            }\r\n            index += 1\r\n\r\n        }\r\n        t1.innerDone = true\r\n        return diffs\r\n    }\r\n\r\n    attemptGroupRelocation(t1, t2, subtrees, route) {\r\n        /* Either t1.childNodes and t2.childNodes have the same length, or\r\n         * there are at least two groups of similar elements can be found.\r\n         * attempts are made at equalizing t1 with t2. First all initial\r\n         * elements with no group affiliation (gaps=true) are removed (if\r\n         * only in t1) or added (if only in t2). Then the creation of a group\r\n         * relocation diff is attempted.\r\n         */\r\n        const gapInformation = getGapInformation(t1, t2, subtrees)\r\n        const gaps1 = gapInformation.gaps1\r\n        const gaps2 = gapInformation.gaps2\r\n        let shortest = Math.min(gaps1.length, gaps2.length)\r\n        let destinationDifferent\r\n        let toGroup\r\n        let group\r\n        let node\r\n        let similarNode\r\n        let testI\r\n        const diffs = []\r\n\r\n\r\n        for (let index2 = 0, index1 = 0; index2 < shortest; index1 += 1, index2 += 1) {\r\n            if (gaps1[index2] === true) {\r\n                node = t1.childNodes[index1]\r\n                if (node.nodeName === '#text') {\r\n                    if (t2.childNodes[index2].nodeName === '#text' && node.data !== t2.childNodes[index2].data) {\r\n                        testI = index1\r\n                        while (t1.childNodes.length > testI + 1 && t1.childNodes[testI + 1].nodeName === '#text') {\r\n                            testI += 1\r\n                            if (t2.childNodes[index2].data === t1.childNodes[testI].data) {\r\n                                similarNode = true\r\n                                break\r\n                            }\r\n                        }\r\n                        if (!similarNode) {\r\n                            diffs.push(new Diff()\r\n                                .setValue(this.options._const.action, this.options._const.modifyTextElement)\r\n                                .setValue(this.options._const.route, route.concat(index2))\r\n                                .setValue(this.options._const.oldValue, node.data)\r\n                                .setValue(this.options._const.newValue, t2.childNodes[index2].data)\r\n                            )\r\n                            return diffs\r\n                        }\r\n                    }\r\n                    diffs.push(new Diff()\r\n                        .setValue(this.options._const.action, this.options._const.removeTextElement)\r\n                        .setValue(this.options._const.route, route.concat(index2))\r\n                        .setValue(this.options._const.value, node.data)\r\n                    )\r\n                    gaps1.splice(index2, 1)\r\n                    shortest = Math.min(gaps1.length, gaps2.length)\r\n                    index2 -= 1\r\n                } else {\r\n                    diffs.push(new Diff()\r\n                        .setValue(this.options._const.action, this.options._const.removeElement)\r\n                        .setValue(this.options._const.route, route.concat(index2))\r\n                        .setValue(this.options._const.element, cloneObj(node))\r\n                    )\r\n                    gaps1.splice(index2, 1)\r\n                    shortest = Math.min(gaps1.length, gaps2.length)\r\n                    index2 -= 1\r\n                }\r\n\r\n            } else if (gaps2[index2] === true) {\r\n                node = t2.childNodes[index2]\r\n                if (node.nodeName === '#text') {\r\n                    diffs.push(new Diff()\r\n                        .setValue(this.options._const.action, this.options._const.addTextElement)\r\n                        .setValue(this.options._const.route, route.concat(index2))\r\n                        .setValue(this.options._const.value, node.data)\r\n                    )\r\n                    gaps1.splice(index2, 0, true)\r\n                    shortest = Math.min(gaps1.length, gaps2.length)\r\n                    index1 -= 1\r\n                } else {\r\n                    diffs.push(new Diff()\r\n                        .setValue(this.options._const.action, this.options._const.addElement)\r\n                        .setValue(this.options._const.route, route.concat(index2))\r\n                        .setValue(this.options._const.element, cloneObj(node))\r\n                    )\r\n                    gaps1.splice(index2, 0, true)\r\n                    shortest = Math.min(gaps1.length, gaps2.length)\r\n                    index1 -= 1\r\n                }\r\n\r\n            } else if (gaps1[index2] !== gaps2[index2]) {\r\n                if (diffs.length > 0) {\r\n                    return diffs\r\n                }\r\n                // group relocation\r\n                group = subtrees[gaps1[index2]]\r\n                toGroup = Math.min(group.newValue, (t1.childNodes.length - group.length))\r\n                if (toGroup !== group.oldValue) {\r\n                    // Check whether destination nodes are different than originating ones.\r\n                    destinationDifferent = false\r\n                    for (let j = 0; j < group.length; j += 1) {\r\n                        if (!roughlyEqual(t1.childNodes[toGroup + j], t1.childNodes[group.oldValue + j], [], false, true)) {\r\n                            destinationDifferent = true\r\n                        }\r\n                    }\r\n                    if (destinationDifferent) {\r\n                        return [new Diff()\r\n                            .setValue(this.options._const.action, this.options._const.relocateGroup)\r\n                            .setValue('groupLength', group.length)\r\n                            .setValue(this.options._const.from, group.oldValue)\r\n                            .setValue(this.options._const.to, toGroup)\r\n                            .setValue(this.options._const.route, route)\r\n                        ]\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return diffs\r\n    }\r\n\r\n    findValueDiff(t1, t2, route) {\r\n        // Differences of value. Only useful if the value/selection/checked value\r\n        // differs from what is represented in the DOM. For example in the case\r\n        // of filled out forms, etc.\r\n        const diffs = []\r\n\r\n        if (t1.selected !== t2.selected) {\r\n            diffs.push(new Diff()\r\n                .setValue(this.options._const.action, this.options._const.modifySelected)\r\n                .setValue(this.options._const.oldValue, t1.selected)\r\n                .setValue(this.options._const.newValue, t2.selected)\r\n                .setValue(this.options._const.route, route)\r\n            )\r\n        }\r\n\r\n        if ((t1.value || t2.value) && t1.value !== t2.value && t1.nodeName !== 'OPTION') {\r\n            diffs.push(new Diff()\r\n                .setValue(this.options._const.action, this.options._const.modifyValue)\r\n                .setValue(this.options._const.oldValue, t1.value || \"\")\r\n                .setValue(this.options._const.newValue, t2.value || \"\")\r\n                .setValue(this.options._const.route, route)\r\n            )\r\n        }\r\n        if (t1.checked !== t2.checked) {\r\n            diffs.push(new Diff()\r\n                .setValue(this.options._const.action, this.options._const.modifyChecked)\r\n                .setValue(this.options._const.oldValue, t1.checked)\r\n                .setValue(this.options._const.newValue, t2.checked)\r\n                .setValue(this.options._const.route, route)\r\n            )\r\n        }\r\n\r\n        return diffs\r\n    }\r\n\r\n}\r\n","import {applyDOM, undoDOM} from \"./dom/index\"\r\nimport {DiffFinder} from \"./virtual/index\"\r\nexport {nodeToObj, stringToObj} from \"./virtual/index\"\r\n\r\nconst DEFAULT_OPTIONS = {\r\n    debug: false,\r\n    diffcap: 10, // Limit for how many diffs are accepting when debugging. Inactive when debug is false.\r\n    maxDepth: false, // False or a numeral. If set to a numeral, limits the level of depth that the the diff mechanism looks for differences. If false, goes through the entire tree.\r\n    maxChildCount: 50, // False or a numeral. If set to a numeral, only does a simplified form of diffing of contents so that the number of diffs cannot be higher than the number of child nodes.\r\n    valueDiffing: true, // Whether to take into consideration the values of forms that differ from auto assigned values (when a user fills out a form).\r\n    // syntax: textDiff: function (node, currentValue, expectedValue, newValue)\r\n    textDiff(node, currentValue, expectedValue, newValue) {\r\n        node.data = newValue\r\n        return\r\n    },\r\n    // empty functions were benchmarked as running faster than both\r\n    // `f && f()` and `if (f) { f(); }`\r\n    preVirtualDiffApply() {},\r\n    postVirtualDiffApply() {},\r\n    preDiffApply() {},\r\n    postDiffApply() {},\r\n    filterOuterDiff: null,\r\n    compress: false, // Whether to work with compressed diffs\r\n    caseSensitive: false, // Whether to honer node name casing\r\n    _const: false, // object with strings for every change types to be used in diffs.\r\n    document: window && window.document ? window.document : false\r\n}\r\n\r\n\r\nexport class DiffDOM {\r\n    constructor(options = {}) {\r\n\r\n        this.options = options\r\n        // IE11 doesn't have Object.assign and buble doesn't translate object spreaders\r\n        // by default, so this is the safest way of doing it currently.\r\n        Object.entries(DEFAULT_OPTIONS).forEach(([key, value]) => {\r\n            if (!Object.prototype.hasOwnProperty.call(this.options, key)) {\r\n                this.options[key] = value\r\n            }\r\n        })\r\n\r\n        if (!this.options._const) {\r\n            const varNames = [\"addAttribute\", \"modifyAttribute\", \"removeAttribute\",\r\n                \"modifyTextElement\", \"relocateGroup\", \"removeElement\", \"addElement\",\r\n                \"removeTextElement\", \"addTextElement\", \"replaceElement\", \"modifyValue\",\r\n                \"modifyChecked\", \"modifySelected\", \"modifyComment\", \"action\", \"route\",\r\n                \"oldValue\", \"newValue\", \"element\", \"group\", \"from\", \"to\", \"name\",\r\n                \"value\", \"data\", \"attributes\", \"nodeName\", \"childNodes\", \"checked\",\r\n                \"selected\"\r\n            ]\r\n            this.options._const = {}\r\n            if (this.options.compress) {\r\n                varNames.forEach((varName, index) => this.options._const[varName] = index)\r\n            } else {\r\n                varNames.forEach(varName => this.options._const[varName] = varName)\r\n            }\r\n        }\r\n\r\n        this.DiffFinder = DiffFinder\r\n\r\n    }\r\n\r\n    apply(tree, diffs) {\r\n        return applyDOM(tree, diffs, this.options)\r\n    }\r\n\r\n    undo(tree, diffs) {\r\n        return undoDOM(tree, diffs, this.options)\r\n    }\r\n\r\n    diff(t1Node, t2Node) {\r\n        const finder = new this.DiffFinder(t1Node, t2Node, this.options)\r\n        return finder.init()\r\n    }\r\n\r\n}\r\n","/**\r\n * Use TraceLogger to figure out function calls inside\r\n * JS objects by wrapping an object with a TraceLogger\r\n * instance.\r\n *\r\n * Pretty-prints the call trace (using unicode box code)\r\n * when tracelogger.toString() is called.\r\n */\r\n\r\n/**\r\n * Wrap an object by calling new TraceLogger(obj)\r\n *\r\n * If you're familiar with Python decorators, this\r\n * does roughly the same thing, adding pre/post\r\n * call hook logging calls so that you can see\r\n * what's going on.\r\n */\r\nexport class TraceLogger {\r\n    constructor(obj = {}) {\r\n        this.pad = \"│   \"\r\n        this.padding = \"\"\r\n        this.tick = 1\r\n        this.messages = []\r\n        const wrapkey = (obj, key) => {\r\n            // trace this function\r\n            const oldfn = obj[key]\r\n            obj[key] = (...args) => {\r\n                this.fin(key, Array.prototype.slice.call(args))\r\n                const result = oldfn.apply(obj, args)\r\n                this.fout(key, result)\r\n                return result\r\n            }\r\n        }\r\n        // can't use Object.keys for prototype walking\r\n        for (let key in obj) {\r\n            if (typeof obj[key] === \"function\") {\r\n                wrapkey(obj, key)\r\n            }\r\n        }\r\n        this.log(\"┌ TRACELOG START\")\r\n    }\r\n    // called when entering a function\r\n    fin(fn, args) {\r\n        this.padding += this.pad\r\n        this.log(`├─> entering ${fn}`, args)\r\n    }\r\n    // called when exiting a function\r\n    fout(fn, result) {\r\n        this.log(\"│<──┘ generated return value\", result)\r\n        this.padding = this.padding.substring(0, this.padding.length - this.pad.length)\r\n    }\r\n    // log message formatting\r\n    format(s, tick) {\r\n        let nf = function(t) {\r\n            t = `${t}`\r\n            while (t.length < 4) {\r\n                t = `0${t}`\r\n            }\r\n            return t\r\n        }\r\n        return `${nf(tick)}> ${this.padding}${s}`\r\n    }\r\n    // log a trace message\r\n    log() {\r\n        let s = Array.prototype.slice.call(arguments)\r\n        const stringCollapse = function(v) {\r\n            if (!v) {\r\n                return \"<falsey>\"\r\n            }\r\n            if (typeof v === \"string\") {\r\n                return v\r\n            }\r\n            if (v instanceof HTMLElement) {\r\n                return v.outerHTML || \"<empty>\"\r\n            }\r\n            if (v instanceof Array) {\r\n                return `[${v.map(stringCollapse).join(\",\")}]`\r\n            }\r\n            return v.toString() || v.valueOf() || \"<unknown>\"\r\n        }\r\n        s = s.map(stringCollapse).join(\", \")\r\n        this.messages.push(this.format(s, this.tick++))\r\n    }\r\n    // turn the log into a structured string with\r\n    // unicode box codes to make it a sensible trace.\r\n    toString() {\r\n        let cap = \"×   \"\r\n        let terminator = \"└───\"\r\n        while (terminator.length <= this.padding.length + this.pad.length) {\r\n            terminator += cap\r\n        }\r\n        let _ = this.padding\r\n        this.padding = \"\"\r\n        terminator = this.format(terminator, this.tick)\r\n        this.padding = _\r\n        return `${this.messages.join(\"\\n\")}\\n${terminator}`\r\n    }\r\n}\r\n"],"names":["objToNode","objNode","insideSvg","options","let","node","nodeName","document","createTextNode","data","createComment","createElementNS","caseSensitive","createElement","attributes","Object","entries","forEach","ref","setAttribute","key","value","childNodes","childNode","appendChild","valueDiffing","checked","selected","getFromRoute","route","slice","length","const","c","splice","applyDiff","tree","diff","newNode","reference","_const","info","preDiffApply","action","addAttribute","name","modifyAttribute","newValue","removeAttribute","modifyTextElement","nodeType","textDiff","oldValue","modifyValue","modifyComment","modifyChecked","modifySelected","replaceElement","parentNode","replaceChild","namespaceURI","relocateGroup","Array","groupLength","map","removeChild","from","index","to","insertBefore","removeElement","addElement","element","removeTextElement","addTextElement","console","log","postDiffApply","applyDOM","diffs","every","swap","obj","p1","p2","tmp","undoDiff","undoDOM","reverse","Diff","this","elementDescriptors","el","output","push","replace","id","findUniqueDescriptors","li","uniqueDescriptors","duplicateDescriptors","descriptor","inUnique","uniqueInBoth","l1","l2","l1Unique","l2Unique","inBoth","keys","removeDone","outerDone","innerDone","valueDone","isEqual","e1","e2","Boolean","e1Attributes","e2Attributes","attribute","roughlyEqual","sameSiblings","preventRecursion","nodeList1","nodeList2","childUniqueDescriptors","cloneObj","JSON","parse","stringify","findCommonSubsets","c1","c2","marked1","marked2","lcsSize","c1Length","c2Length","matches","subsetsSame","some","i","c1Desc","c2Desc","description","c1Index","c1Element","c2Index","c2Element","makeArray","n","v","getGapInformation","t1","t2","stable","gaps1","gaps2","group","subset","endOld","endNew","j","markSubTrees","oldTree","newTree","oldChildren","newChildren","subsets","returnIndex","arguments","item","subsetsAge","toString","setValue","aKey","aValue","DiffTracker","list","getFromVirtualRoute","nodeIndex","applyVirtualDiff","routeInfo","newSubsets","movedNode","splitLength","delete","filter","concat","applyVirtual","nodeToObj","aNode","prototype","call","undefined","type","includes","toLowerCase","add","fn","tagRE","empty","create","attrRE","lookup","area","base","br","col","embed","hr","img","input","keygen","link","menuItem","meta","param","source","track","wbr","parseTag","tag","res","match","charAt","voidElement","toUpperCase","html","components","current","result","level","arr","byTag","inComponent","parent","isOpen","start","nextChar","indexOf","tagName","end","cleanObj","child","stringToObj","string","DiffFinder","t1Node","t2Node","HTMLElement","diffcount","foundAll","debug","t1Orig","t2Orig","tracker","init","findDiffs","diffcap","window","diffError","Error","findNextDiff","error","fdiffs","maxDepth","findOuterDiff","filterOuterDiff","findInnerDiff","findValueDiff","attr","attr1","attr2","attrLength","pos","maxNodeDiffCount","Math","abs","sort","t1ChildNodes","t2ChildNodes","last","max","childNodesLengthDifference","maxChildCount","subtrees","attemptGroupRelocation","destinationDifferent","toGroup","similarNode","testI","gapInformation","shortest","min","index2","index1","DEFAULT_OPTIONS","currentValue","expectedValue","preVirtualDiffApply","postVirtualDiffApply","compress","DiffDOM","hasOwnProperty","varNames","varName","apply","undo","TraceLogger","pad","padding","tick","messages","wrapkey","oldfn","fin","args","fout","substring","format","s","t","stringCollapse","outerHTML","join","valueOf","terminator","_"],"mappings":"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"}