{"version":3,"file":"diffDOM.js","sources":["../src/diffDOM/dom/fromVirtual.js","../src/diffDOM/dom/apply.js","../src/diffDOM/dom/undo.js","../src/diffDOM/virtual/helpers.js","../src/diffDOM/virtual/apply.js","../src/diffDOM/virtual/fromDOM.js","../src/diffDOM/virtual/fromString.js","../src/diffDOM/virtual/diff.js","../src/diffDOM/index.js","../src/TraceLogger.js"],"sourcesContent":["export function objToNode(objNode, insideSvg, options) {\n    let node\n    if (objNode.nodeName === \"#text\") {\n        node = options.document.createTextNode(objNode.data)\n    } else if (objNode.nodeName === \"#comment\") {\n        node = options.document.createComment(objNode.data)\n    } else {\n        if (insideSvg) {\n            node = options.document.createElementNS(\n                \"http://www.w3.org/2000/svg\",\n                objNode.nodeName\n            )\n        } else if (objNode.nodeName.toLowerCase() === \"svg\") {\n            node = options.document.createElementNS(\n                \"http://www.w3.org/2000/svg\",\n                \"svg\"\n            )\n            insideSvg = true\n        } else {\n            node = options.document.createElement(objNode.nodeName)\n        }\n        if (objNode.attributes) {\n            Object.entries(objNode.attributes).forEach(([key, value]) =>\n                node.setAttribute(key, value)\n            )\n        }\n        if (objNode.childNodes) {\n            objNode.childNodes.forEach((childNode) =>\n                node.appendChild(objToNode(childNode, insideSvg, options))\n            )\n        }\n        if (options.valueDiffing) {\n            if (objNode.value) {\n                node.value = objNode.value\n            }\n            if (objNode.checked) {\n                node.checked = objNode.checked\n            }\n            if (objNode.selected) {\n                node.selected = objNode.selected\n            }\n        }\n    }\n    return node\n}\n","import { objToNode } from \"./fromVirtual\"\n\n// ===== Apply a diff =====\n\nfunction getFromRoute(node, route) {\n    route = route.slice()\n    while (route.length > 0) {\n        if (!node.childNodes) {\n            return false\n        }\n        const c = route.splice(0, 1)[0]\n        node = node.childNodes[c]\n    }\n    return node\n}\n\nexport function applyDiff(\n    tree,\n    diff,\n    options // {preDiffApply, postDiffApply, textDiff, valueDiffing, _const}\n) {\n    let node = getFromRoute(tree, diff[options._const.route])\n    let newNode\n    let reference\n    let route\n    let nodeArray\n    let c\n\n    // pre-diff hook\n    const info = {\n        diff,\n        node,\n    }\n\n    if (options.preDiffApply(info)) {\n        return true\n    }\n\n    switch (diff[options._const.action]) {\n        case options._const.addAttribute:\n            if (!node || !node.setAttribute) {\n                return false\n            }\n            node.setAttribute(\n                diff[options._const.name],\n                diff[options._const.value]\n            )\n            break\n        case options._const.modifyAttribute:\n            if (!node || !node.setAttribute) {\n                return false\n            }\n            node.setAttribute(\n                diff[options._const.name],\n                diff[options._const.newValue]\n            )\n            if (\n                node.nodeName === \"INPUT\" &&\n                diff[options._const.name] === \"value\"\n            ) {\n                node.value = diff[options._const.newValue]\n            }\n            break\n        case options._const.removeAttribute:\n            if (!node || !node.removeAttribute) {\n                return false\n            }\n            node.removeAttribute(diff[options._const.name])\n            break\n        case options._const.modifyTextElement:\n            if (!node || node.nodeType !== 3) {\n                return false\n            }\n            options.textDiff(\n                node,\n                node.data,\n                diff[options._const.oldValue],\n                diff[options._const.newValue]\n            )\n            break\n        case options._const.modifyValue:\n            if (!node || typeof node.value === \"undefined\") {\n                return false\n            }\n            node.value = diff[options._const.newValue]\n            break\n        case options._const.modifyComment:\n            if (!node || typeof node.data === \"undefined\") {\n                return false\n            }\n            options.textDiff(\n                node,\n                node.data,\n                diff[options._const.oldValue],\n                diff[options._const.newValue]\n            )\n            break\n        case options._const.modifyChecked:\n            if (!node || typeof node.checked === \"undefined\") {\n                return false\n            }\n            node.checked = diff[options._const.newValue]\n            break\n        case options._const.modifySelected:\n            if (!node || typeof node.selected === \"undefined\") {\n                return false\n            }\n            node.selected = diff[options._const.newValue]\n            break\n        case options._const.replaceElement:\n            node.parentNode.replaceChild(\n                objToNode(\n                    diff[options._const.newValue],\n                    diff[options._const.newValue].nodeName.toLowerCase() ===\n                        \"svg\",\n                    options\n                ),\n                node\n            )\n            break\n        case options._const.relocateGroup:\n            nodeArray = Array(...new Array(diff.groupLength)).map(() =>\n                node.removeChild(node.childNodes[diff[options._const.from]])\n            )\n            nodeArray.forEach((childNode, index) => {\n                if (index === 0) {\n                    reference = node.childNodes[diff[options._const.to]]\n                }\n                node.insertBefore(childNode, reference || null)\n            })\n            break\n        case options._const.removeElement:\n            node.parentNode.removeChild(node)\n            break\n        case options._const.addElement:\n            route = diff[options._const.route].slice()\n            c = route.splice(route.length - 1, 1)[0]\n            node = getFromRoute(tree, route)\n            node.insertBefore(\n                objToNode(\n                    diff[options._const.element],\n                    node.namespaceURI === \"http://www.w3.org/2000/svg\",\n                    options\n                ),\n                node.childNodes[c] || null\n            )\n            break\n        case options._const.removeTextElement:\n            if (!node || node.nodeType !== 3) {\n                return false\n            }\n            node.parentNode.removeChild(node)\n            break\n        case options._const.addTextElement:\n            route = diff[options._const.route].slice()\n            c = route.splice(route.length - 1, 1)[0]\n            newNode = options.document.createTextNode(\n                diff[options._const.value]\n            )\n            node = getFromRoute(tree, route)\n            if (!node || !node.childNodes) {\n                return false\n            }\n            node.insertBefore(newNode, node.childNodes[c] || null)\n            break\n        default:\n            console.log(\"unknown action\")\n    }\n\n    // if a new node was created, we might be interested in its\n    // post diff hook\n    info.newNode = newNode\n    options.postDiffApply(info)\n\n    return true\n}\n\nexport function applyDOM(tree, diffs, options) {\n    return diffs.every((diff) => applyDiff(tree, diff, options))\n}\n","import { applyDiff } from \"./apply\"\n\n// ===== Undo a diff =====\n\nfunction swap(obj, p1, p2) {\n    const tmp = obj[p1]\n    obj[p1] = obj[p2]\n    obj[p2] = tmp\n}\n\nfunction undoDiff(\n    tree,\n    diff,\n    options // {preDiffApply, postDiffApply, textDiff, valueDiffing, _const}\n) {\n    switch (diff[options._const.action]) {\n        case options._const.addAttribute:\n            diff[options._const.action] = options._const.removeAttribute\n            applyDiff(tree, diff, options)\n            break\n        case options._const.modifyAttribute:\n            swap(diff, options._const.oldValue, options._const.newValue)\n            applyDiff(tree, diff, options)\n            break\n        case options._const.removeAttribute:\n            diff[options._const.action] = options._const.addAttribute\n            applyDiff(tree, diff, options)\n            break\n        case options._const.modifyTextElement:\n            swap(diff, options._const.oldValue, options._const.newValue)\n            applyDiff(tree, diff, options)\n            break\n        case options._const.modifyValue:\n            swap(diff, options._const.oldValue, options._const.newValue)\n            applyDiff(tree, diff, options)\n            break\n        case options._const.modifyComment:\n            swap(diff, options._const.oldValue, options._const.newValue)\n            applyDiff(tree, diff, options)\n            break\n        case options._const.modifyChecked:\n            swap(diff, options._const.oldValue, options._const.newValue)\n            applyDiff(tree, diff, options)\n            break\n        case options._const.modifySelected:\n            swap(diff, options._const.oldValue, options._const.newValue)\n            applyDiff(tree, diff, options)\n            break\n        case options._const.replaceElement:\n            swap(diff, options._const.oldValue, options._const.newValue)\n            applyDiff(tree, diff, options)\n            break\n        case options._const.relocateGroup:\n            swap(diff, options._const.from, options._const.to)\n            applyDiff(tree, diff, options)\n            break\n        case options._const.removeElement:\n            diff[options._const.action] = options._const.addElement\n            applyDiff(tree, diff, options)\n            break\n        case options._const.addElement:\n            diff[options._const.action] = options._const.removeElement\n            applyDiff(tree, diff, options)\n            break\n        case options._const.removeTextElement:\n            diff[options._const.action] = options._const.addTextElement\n            applyDiff(tree, diff, options)\n            break\n        case options._const.addTextElement:\n            diff[options._const.action] = options._const.removeTextElement\n            applyDiff(tree, diff, options)\n            break\n        default:\n            console.log(\"unknown action\")\n    }\n}\n\nexport function undoDOM(tree, diffs, options) {\n    if (!diffs.length) {\n        diffs = [diffs]\n    }\n    diffs = diffs.slice()\n    diffs.reverse()\n    diffs.forEach((diff) => {\n        undoDiff(tree, diff, options)\n    })\n}\n","export class Diff {\n    constructor(options = {}) {\n        Object.entries(options).forEach(([key, value]) => (this[key] = value))\n    }\n\n    toString() {\n        return JSON.stringify(this)\n    }\n\n    setValue(aKey, aValue) {\n        this[aKey] = aValue\n        return this\n    }\n}\n\nfunction elementDescriptors(el) {\n    const output = []\n    output.push(el.nodeName)\n    if (el.nodeName !== \"#text\" && el.nodeName !== \"#comment\") {\n        if (el.attributes) {\n            if (el.attributes[\"class\"]) {\n                output.push(\n                    `${el.nodeName}.${el.attributes[\"class\"].replace(\n                        / /g,\n                        \".\"\n                    )}`\n                )\n            }\n            if (el.attributes.id) {\n                output.push(`${el.nodeName}#${el.attributes.id}`)\n            }\n        }\n    }\n    return output\n}\n\nfunction findUniqueDescriptors(li) {\n    const uniqueDescriptors = {}\n    const duplicateDescriptors = {}\n\n    li.forEach((node) => {\n        elementDescriptors(node).forEach((descriptor) => {\n            const inUnique = descriptor in uniqueDescriptors\n            const inDupes = descriptor in duplicateDescriptors\n            if (!inUnique && !inDupes) {\n                uniqueDescriptors[descriptor] = true\n            } else if (inUnique) {\n                delete uniqueDescriptors[descriptor]\n                duplicateDescriptors[descriptor] = true\n            }\n        })\n    })\n\n    return uniqueDescriptors\n}\n\nfunction uniqueInBoth(l1, l2) {\n    const l1Unique = findUniqueDescriptors(l1)\n    const l2Unique = findUniqueDescriptors(l2)\n    const inBoth = {}\n\n    Object.keys(l1Unique).forEach((key) => {\n        if (l2Unique[key]) {\n            inBoth[key] = true\n        }\n    })\n\n    return inBoth\n}\n\nexport function removeDone(tree) {\n    delete tree.outerDone\n    delete tree.innerDone\n    delete tree.valueDone\n    if (tree.childNodes) {\n        return tree.childNodes.every(removeDone)\n    } else {\n        return true\n    }\n}\n\nexport function isEqual(e1, e2) {\n    if (\n        ![\"nodeName\", \"value\", \"checked\", \"selected\", \"data\"].every(\n            (element) => {\n                if (e1[element] !== e2[element]) {\n                    return false\n                }\n                return true\n            }\n        )\n    ) {\n        return false\n    }\n\n    if (Boolean(e1.attributes) !== Boolean(e2.attributes)) {\n        return false\n    }\n\n    if (Boolean(e1.childNodes) !== Boolean(e2.childNodes)) {\n        return false\n    }\n    if (e1.attributes) {\n        const e1Attributes = Object.keys(e1.attributes)\n        const e2Attributes = Object.keys(e2.attributes)\n\n        if (e1Attributes.length !== e2Attributes.length) {\n            return false\n        }\n        if (\n            !e1Attributes.every((attribute) => {\n                if (e1.attributes[attribute] !== e2.attributes[attribute]) {\n                    return false\n                }\n                return true\n            })\n        ) {\n            return false\n        }\n    }\n    if (e1.childNodes) {\n        if (e1.childNodes.length !== e2.childNodes.length) {\n            return false\n        }\n        if (\n            !e1.childNodes.every((childNode, index) =>\n                isEqual(childNode, e2.childNodes[index])\n            )\n        ) {\n            return false\n        }\n    }\n\n    return true\n}\n\nexport function roughlyEqual(\n    e1,\n    e2,\n    uniqueDescriptors,\n    sameSiblings,\n    preventRecursion\n) {\n    if (!e1 || !e2) {\n        return false\n    }\n\n    if (e1.nodeName !== e2.nodeName) {\n        return false\n    }\n\n    if (e1.nodeName === \"#text\") {\n        // Note that we initially don't care what the text content of a node is,\n        // the mere fact that it's the same tag and \"has text\" means it's roughly\n        // equal, and then we can find out the true text difference later.\n        return preventRecursion ? true : e1.data === e2.data\n    }\n\n    if (e1.nodeName in uniqueDescriptors) {\n        return true\n    }\n\n    if (e1.attributes && e2.attributes) {\n        if (e1.attributes.id) {\n            if (e1.attributes.id !== e2.attributes.id) {\n                return false\n            } else {\n                const idDescriptor = `${e1.nodeName}#${e1.attributes.id}`\n                if (idDescriptor in uniqueDescriptors) {\n                    return true\n                }\n            }\n        }\n        if (\n            e1.attributes[\"class\"] &&\n            e1.attributes[\"class\"] === e2.attributes[\"class\"]\n        ) {\n            const classDescriptor = `${e1.nodeName}.${e1.attributes[\n                \"class\"\n            ].replace(/ /g, \".\")}`\n            if (classDescriptor in uniqueDescriptors) {\n                return true\n            }\n        }\n    }\n\n    if (sameSiblings) {\n        return true\n    }\n\n    const nodeList1 = e1.childNodes ? e1.childNodes.slice().reverse() : []\n    const nodeList2 = e2.childNodes ? e2.childNodes.slice().reverse() : []\n\n    if (nodeList1.length !== nodeList2.length) {\n        return false\n    }\n\n    if (preventRecursion) {\n        return nodeList1.every(\n            (element, index) => element.nodeName === nodeList2[index].nodeName\n        )\n    } else {\n        // note: we only allow one level of recursion at any depth. If 'preventRecursion'\n        // was not set, we must explicitly force it to true for child iterations.\n        const childUniqueDescriptors = uniqueInBoth(nodeList1, nodeList2)\n        return nodeList1.every((element, index) =>\n            roughlyEqual(\n                element,\n                nodeList2[index],\n                childUniqueDescriptors,\n                true,\n                true\n            )\n        )\n    }\n}\n\nexport function cloneObj(obj) {\n    //  TODO: Do we really need to clone here? Is it not enough to just return the original object?\n    return JSON.parse(JSON.stringify(obj))\n}\n/**\n * based on https://en.wikibooks.org/wiki/Algorithm_implementation/Strings/Longest_common_substring#JavaScript\n */\nfunction findCommonSubsets(c1, c2, marked1, marked2) {\n    let lcsSize = 0\n    let index = []\n    const c1Length = c1.length\n    const c2Length = c2.length\n\n    const // set up the matching table\n        matches = Array(...new Array(c1Length + 1)).map(() => [])\n\n    const uniqueDescriptors = uniqueInBoth(c1, c2)\n\n    let // If all of the elements are the same tag, id and class, then we can\n        // consider them roughly the same even if they have a different number of\n        // children. This will reduce removing and re-adding similar elements.\n        subsetsSame = c1Length === c2Length\n\n    if (subsetsSame) {\n        c1.some((element, i) => {\n            const c1Desc = elementDescriptors(element)\n            const c2Desc = elementDescriptors(c2[i])\n            if (c1Desc.length !== c2Desc.length) {\n                subsetsSame = false\n                return true\n            }\n            c1Desc.some((description, i) => {\n                if (description !== c2Desc[i]) {\n                    subsetsSame = false\n                    return true\n                }\n            })\n            if (!subsetsSame) {\n                return true\n            }\n        })\n    }\n\n    // fill the matches with distance values\n    for (let c1Index = 0; c1Index < c1Length; c1Index++) {\n        const c1Element = c1[c1Index]\n        for (let c2Index = 0; c2Index < c2Length; c2Index++) {\n            const c2Element = c2[c2Index]\n            if (\n                !marked1[c1Index] &&\n                !marked2[c2Index] &&\n                roughlyEqual(\n                    c1Element,\n                    c2Element,\n                    uniqueDescriptors,\n                    subsetsSame\n                )\n            ) {\n                matches[c1Index + 1][c2Index + 1] = matches[c1Index][c2Index]\n                    ? matches[c1Index][c2Index] + 1\n                    : 1\n                if (matches[c1Index + 1][c2Index + 1] >= lcsSize) {\n                    lcsSize = matches[c1Index + 1][c2Index + 1]\n                    index = [c1Index + 1, c2Index + 1]\n                }\n            } else {\n                matches[c1Index + 1][c2Index + 1] = 0\n            }\n        }\n    }\n\n    if (lcsSize === 0) {\n        return false\n    }\n\n    return {\n        oldValue: index[0] - lcsSize,\n        newValue: index[1] - lcsSize,\n        length: lcsSize,\n    }\n}\n\n/**\n * This should really be a predefined function in Array...\n */\nfunction makeArray(n, v) {\n    return Array(...new Array(n)).map(() => v)\n}\n\n/**\n * Generate arrays that indicate which node belongs to which subset,\n * or whether it's actually an orphan node, existing in only one\n * of the two trees, rather than somewhere in both.\n *\n * So if t1 = <img><canvas><br>, t2 = <canvas><br><img>.\n * The longest subset is \"<canvas><br>\" (length 2), so it will group 0.\n * The second longest is \"<img>\" (length 1), so it will be group 1.\n * gaps1 will therefore be [1,0,0] and gaps2 [0,0,1].\n *\n * If an element is not part of any group, it will stay being 'true', which\n * is the initial value. For example:\n * t1 = <img><p></p><br><canvas>, t2 = <b></b><br><canvas><img>\n *\n * The \"<p></p>\" and \"<b></b>\" do only show up in one of the two and will\n * therefore be marked by \"true\". The remaining parts are parts of the\n * groups 0 and 1:\n * gaps1 = [1, true, 0, 0], gaps2 = [true, 0, 0, 1]\n *\n */\nexport function getGapInformation(t1, t2, stable) {\n    const gaps1 = t1.childNodes ? makeArray(t1.childNodes.length, true) : []\n    const gaps2 = t2.childNodes ? makeArray(t2.childNodes.length, true) : []\n    let group = 0\n\n    // give elements from the same subset the same group number\n    stable.forEach((subset) => {\n        const endOld = subset.oldValue + subset.length\n        const endNew = subset.newValue + subset.length\n\n        for (let j = subset.oldValue; j < endOld; j += 1) {\n            gaps1[j] = group\n        }\n        for (let j = subset.newValue; j < endNew; j += 1) {\n            gaps2[j] = group\n        }\n        group += 1\n    })\n\n    return {\n        gaps1,\n        gaps2,\n    }\n}\n\n/**\n * Find all matching subsets, based on immediate child differences only.\n */\nexport function markSubTrees(oldTree, newTree) {\n    // note: the child lists are views, and so update as we update old/newTree\n    const oldChildren = oldTree.childNodes ? oldTree.childNodes : []\n\n    const newChildren = newTree.childNodes ? newTree.childNodes : []\n    const marked1 = makeArray(oldChildren.length, false)\n    const marked2 = makeArray(newChildren.length, false)\n    const subsets = []\n    let subset = true\n\n    const returnIndex = function () {\n        return arguments[1]\n    }\n\n    const markBoth = (i) => {\n        marked1[subset.oldValue + i] = true\n        marked2[subset.newValue + i] = true\n    }\n\n    while (subset) {\n        subset = findCommonSubsets(oldChildren, newChildren, marked1, marked2)\n        if (subset) {\n            subsets.push(subset)\n            const subsetArray = Array(...new Array(subset.length)).map(\n                returnIndex\n            )\n            subsetArray.forEach((item) => markBoth(item))\n        }\n    }\n\n    oldTree.subsets = subsets\n    oldTree.subsetsAge = 100\n    return subsets\n}\n\nexport class DiffTracker {\n    constructor() {\n        this.list = []\n    }\n\n    add(diffs) {\n        this.list.push(...diffs)\n    }\n    forEach(fn) {\n        this.list.forEach((li) => fn(li))\n    }\n}\n","import { cloneObj } from \"./helpers\"\n\n// ===== Apply a virtual diff =====\n\nfunction getFromVirtualRoute(tree, route) {\n    let node = tree\n    let parentNode\n    let nodeIndex\n\n    route = route.slice()\n    while (route.length > 0) {\n        if (!node.childNodes) {\n            return false\n        }\n        nodeIndex = route.splice(0, 1)[0]\n        parentNode = node\n        node = node.childNodes[nodeIndex]\n    }\n    return {\n        node,\n        parentNode,\n        nodeIndex,\n    }\n}\n\nfunction applyVirtualDiff(\n    tree,\n    diff,\n    options // {preVirtualDiffApply, postVirtualDiffApply, _const}\n) {\n    const routeInfo = getFromVirtualRoute(tree, diff[options._const.route])\n    let node = routeInfo.node\n    const parentNode = routeInfo.parentNode\n    const nodeIndex = routeInfo.nodeIndex\n    const newSubsets = []\n\n    // pre-diff hook\n    const info = {\n        diff,\n        node,\n    }\n\n    if (options.preVirtualDiffApply(info)) {\n        return true\n    }\n\n    let newNode\n    let nodeArray\n    let route\n    let c\n    switch (diff[options._const.action]) {\n        case options._const.addAttribute:\n            if (!node.attributes) {\n                node.attributes = {}\n            }\n\n            node.attributes[diff[options._const.name]] =\n                diff[options._const.value]\n\n            if (diff[options._const.name] === \"checked\") {\n                node.checked = true\n            } else if (diff[options._const.name] === \"selected\") {\n                node.selected = true\n            } else if (\n                node.nodeName === \"INPUT\" &&\n                diff[options._const.name] === \"value\"\n            ) {\n                node.value = diff[options._const.value]\n            }\n\n            break\n        case options._const.modifyAttribute:\n            node.attributes[diff[options._const.name]] =\n                diff[options._const.newValue]\n            break\n        case options._const.removeAttribute:\n            delete node.attributes[diff[options._const.name]]\n\n            if (Object.keys(node.attributes).length === 0) {\n                delete node.attributes\n            }\n\n            if (diff[options._const.name] === \"checked\") {\n                node.checked = false\n            } else if (diff[options._const.name] === \"selected\") {\n                delete node.selected\n            } else if (\n                node.nodeName === \"INPUT\" &&\n                diff[options._const.name] === \"value\"\n            ) {\n                delete node.value\n            }\n\n            break\n        case options._const.modifyTextElement:\n            node.data = diff[options._const.newValue]\n            break\n        case options._const.modifyValue:\n            node.value = diff[options._const.newValue]\n            break\n        case options._const.modifyComment:\n            node.data = diff[options._const.newValue]\n            break\n        case options._const.modifyChecked:\n            node.checked = diff[options._const.newValue]\n            break\n        case options._const.modifySelected:\n            node.selected = diff[options._const.newValue]\n            break\n        case options._const.replaceElement:\n            newNode = cloneObj(diff[options._const.newValue])\n            newNode.outerDone = true\n            newNode.innerDone = true\n            newNode.valueDone = true\n            parentNode.childNodes[nodeIndex] = newNode\n            break\n        case options._const.relocateGroup:\n            nodeArray = node.childNodes\n                .splice(diff[options._const.from], diff.groupLength)\n                .reverse()\n            nodeArray.forEach((movedNode) =>\n                node.childNodes.splice(diff[options._const.to], 0, movedNode)\n            )\n            if (node.subsets) {\n                node.subsets.forEach((map) => {\n                    if (\n                        diff[options._const.from] < diff[options._const.to] &&\n                        map.oldValue <= diff[options._const.to] &&\n                        map.oldValue > diff[options._const.from]\n                    ) {\n                        map.oldValue -= diff.groupLength\n                        const splitLength =\n                            map.oldValue + map.length - diff[options._const.to]\n                        if (splitLength > 0) {\n                            // new insertion splits map.\n                            newSubsets.push({\n                                oldValue:\n                                    diff[options._const.to] + diff.groupLength,\n                                newValue:\n                                    map.newValue + map.length - splitLength,\n                                length: splitLength,\n                            })\n                            map.length -= splitLength\n                        }\n                    } else if (\n                        diff[options._const.from] > diff[options._const.to] &&\n                        map.oldValue > diff[options._const.to] &&\n                        map.oldValue < diff[options._const.from]\n                    ) {\n                        map.oldValue += diff.groupLength\n                        const splitLength =\n                            map.oldValue + map.length - diff[options._const.to]\n                        if (splitLength > 0) {\n                            // new insertion splits map.\n                            newSubsets.push({\n                                oldValue:\n                                    diff[options._const.to] + diff.groupLength,\n                                newValue:\n                                    map.newValue + map.length - splitLength,\n                                length: splitLength,\n                            })\n                            map.length -= splitLength\n                        }\n                    } else if (map.oldValue === diff[options._const.from]) {\n                        map.oldValue = diff[options._const.to]\n                    }\n                })\n            }\n\n            break\n        case options._const.removeElement:\n            parentNode.childNodes.splice(nodeIndex, 1)\n            if (parentNode.subsets) {\n                parentNode.subsets.forEach((map) => {\n                    if (map.oldValue > nodeIndex) {\n                        map.oldValue -= 1\n                    } else if (map.oldValue === nodeIndex) {\n                        map.delete = true\n                    } else if (\n                        map.oldValue < nodeIndex &&\n                        map.oldValue + map.length > nodeIndex\n                    ) {\n                        if (map.oldValue + map.length - 1 === nodeIndex) {\n                            map.length--\n                        } else {\n                            newSubsets.push({\n                                newValue:\n                                    map.newValue + nodeIndex - map.oldValue,\n                                oldValue: nodeIndex,\n                                length:\n                                    map.length - nodeIndex + map.oldValue - 1,\n                            })\n                            map.length = nodeIndex - map.oldValue\n                        }\n                    }\n                })\n            }\n            node = parentNode\n            break\n        case options._const.addElement:\n            route = diff[options._const.route].slice()\n            c = route.splice(route.length - 1, 1)[0]\n            node = getFromVirtualRoute(tree, route).node\n            newNode = cloneObj(diff[options._const.element])\n            newNode.outerDone = true\n            newNode.innerDone = true\n            newNode.valueDone = true\n\n            if (!node.childNodes) {\n                node.childNodes = []\n            }\n\n            if (c >= node.childNodes.length) {\n                node.childNodes.push(newNode)\n            } else {\n                node.childNodes.splice(c, 0, newNode)\n            }\n            if (node.subsets) {\n                node.subsets.forEach((map) => {\n                    if (map.oldValue >= c) {\n                        map.oldValue += 1\n                    } else if (\n                        map.oldValue < c &&\n                        map.oldValue + map.length > c\n                    ) {\n                        const splitLength = map.oldValue + map.length - c\n                        newSubsets.push({\n                            newValue: map.newValue + map.length - splitLength,\n                            oldValue: c + 1,\n                            length: splitLength,\n                        })\n                        map.length -= splitLength\n                    }\n                })\n            }\n            break\n        case options._const.removeTextElement:\n            parentNode.childNodes.splice(nodeIndex, 1)\n            if (parentNode.nodeName === \"TEXTAREA\") {\n                delete parentNode.value\n            }\n            if (parentNode.subsets) {\n                parentNode.subsets.forEach((map) => {\n                    if (map.oldValue > nodeIndex) {\n                        map.oldValue -= 1\n                    } else if (map.oldValue === nodeIndex) {\n                        map.delete = true\n                    } else if (\n                        map.oldValue < nodeIndex &&\n                        map.oldValue + map.length > nodeIndex\n                    ) {\n                        if (map.oldValue + map.length - 1 === nodeIndex) {\n                            map.length--\n                        } else {\n                            newSubsets.push({\n                                newValue:\n                                    map.newValue + nodeIndex - map.oldValue,\n                                oldValue: nodeIndex,\n                                length:\n                                    map.length - nodeIndex + map.oldValue - 1,\n                            })\n                            map.length = nodeIndex - map.oldValue\n                        }\n                    }\n                })\n            }\n            node = parentNode\n            break\n        case options._const.addTextElement:\n            route = diff[options._const.route].slice()\n            c = route.splice(route.length - 1, 1)[0]\n            newNode = {}\n            newNode.nodeName = \"#text\"\n            newNode.data = diff[options._const.value]\n            node = getFromVirtualRoute(tree, route).node\n            if (!node.childNodes) {\n                node.childNodes = []\n            }\n\n            if (c >= node.childNodes.length) {\n                node.childNodes.push(newNode)\n            } else {\n                node.childNodes.splice(c, 0, newNode)\n            }\n            if (node.nodeName === \"TEXTAREA\") {\n                node.value = diff[options._const.newValue]\n            }\n            if (node.subsets) {\n                node.subsets.forEach((map) => {\n                    if (map.oldValue >= c) {\n                        map.oldValue += 1\n                    }\n                    if (map.oldValue < c && map.oldValue + map.length > c) {\n                        const splitLength = map.oldValue + map.length - c\n                        newSubsets.push({\n                            newValue: map.newValue + map.length - splitLength,\n                            oldValue: c + 1,\n                            length: splitLength,\n                        })\n                        map.length -= splitLength\n                    }\n                })\n            }\n            break\n        default:\n            console.log(\"unknown action\")\n    }\n\n    if (node.subsets) {\n        node.subsets = node.subsets.filter(\n            (map) => !map.delete && map.oldValue !== map.newValue\n        )\n        if (newSubsets.length) {\n            node.subsets = node.subsets.concat(newSubsets)\n        }\n    }\n\n    // capture newNode for the callback\n    info.newNode = newNode\n    options.postVirtualDiffApply(info)\n\n    return\n}\n\nexport function applyVirtual(tree, diffs, options) {\n    diffs.forEach((diff) => {\n        applyVirtualDiff(tree, diff, options)\n    })\n    return true\n}\n","export function nodeToObj(aNode, options = {}) {\n    const objNode = {}\n    objNode.nodeName = aNode.nodeName\n    if (objNode.nodeName === \"#text\" || objNode.nodeName === \"#comment\") {\n        objNode.data = aNode.data\n    } else {\n        if (aNode.attributes && aNode.attributes.length > 0) {\n            objNode.attributes = {}\n            const nodeArray = Array.prototype.slice.call(aNode.attributes)\n            nodeArray.forEach(\n                (attribute) =>\n                    (objNode.attributes[attribute.name] = attribute.value)\n            )\n        }\n        if (objNode.nodeName === \"TEXTAREA\") {\n            objNode.value = aNode.value\n        } else if (aNode.childNodes && aNode.childNodes.length > 0) {\n            objNode.childNodes = []\n            const nodeArray = Array.prototype.slice.call(aNode.childNodes)\n            nodeArray.forEach((childNode) =>\n                objNode.childNodes.push(nodeToObj(childNode, options))\n            )\n        }\n        if (options.valueDiffing) {\n            if (\n                aNode.checked !== undefined &&\n                aNode.type &&\n                [\"radio\", \"checkbox\"].includes(aNode.type.toLowerCase())\n            ) {\n                objNode.checked = aNode.checked\n            } else if (aNode.value !== undefined) {\n                objNode.value = aNode.value\n            }\n            if (aNode.selected !== undefined) {\n                objNode.selected = aNode.selected\n            }\n        }\n    }\n    return objNode\n}\n","// from html-parse-stringify (MIT)\n\nconst tagRE = /<(?:\"[^\"]*\"['\"]*|'[^']*'['\"]*|[^'\">])+>/g\n\n// re-used obj for quick lookups of components\nconst empty = Object.create ? Object.create(null) : {}\nconst attrRE = /\\s([^'\"/\\s><]+?)[\\s/>]|([^\\s=]+)=\\s?(\".*?\"|'.*?')/g\n\nfunction unescape(string) {\n    return string\n        .replace(/&lt;/g, \"<\")\n        .replace(/&gt;/g, \">\")\n        .replace(/&amp;/g, \"&\")\n}\n\n// create optimized lookup object for\n// void elements as listed here:\n// http://www.w3.org/html/wg/drafts/html/master/syntax.html#void-elements\nconst lookup = {\n    area: true,\n    base: true,\n    br: true,\n    col: true,\n    embed: true,\n    hr: true,\n    img: true,\n    input: true,\n    keygen: true,\n    link: true,\n    menuItem: true,\n    meta: true,\n    param: true,\n    source: true,\n    track: true,\n    wbr: true,\n}\n\nfunction parseTag(tag) {\n    const res = {\n        nodeName: \"\",\n        attributes: {},\n    }\n\n    let tagMatch = tag.match(/<\\/?([^\\s]+?)[/\\s>]/)\n    if (tagMatch) {\n        res.nodeName = tagMatch[1].toUpperCase()\n        if (lookup[tagMatch[1]] || tag.charAt(tag.length - 2) === \"/\") {\n            res.voidElement = true\n        }\n\n        // handle comment tag\n        if (res.nodeName.startsWith(\"!--\")) {\n            const endIndex = tag.indexOf(\"-->\")\n            return {\n                type: \"comment\",\n                data: endIndex !== -1 ? tag.slice(4, endIndex) : \"\",\n            }\n        }\n    }\n\n    let reg = new RegExp(attrRE)\n    let result = null\n    let done = false\n    while (!done) {\n        result = reg.exec(tag)\n\n        if (result === null) {\n            done = true\n        } else if (result[0].trim()) {\n            if (result[1]) {\n                let attr = result[1].trim()\n                let arr = [attr, \"\"]\n\n                if (attr.indexOf(\"=\") > -1) arr = attr.split(\"=\")\n\n                res.attributes[arr[0]] = arr[1]\n                reg.lastIndex--\n            } else if (result[2])\n                res.attributes[result[2]] = result[3]\n                    .trim()\n                    .substring(1, result[3].length - 1)\n        }\n    }\n\n    return res\n}\n\nfunction parse(html, options = { components: empty }) {\n    const result = []\n    let current\n    let level = -1\n    const arr = []\n    let inComponent = false\n\n    // handle text at top level\n    if (html.indexOf(\"<\") !== 0) {\n        const end = html.indexOf(\"<\")\n        result.push({\n            nodeName: \"#text\",\n            data: end === -1 ? html : html.substring(0, end),\n        })\n    }\n\n    html.replace(tagRE, (tag, index) => {\n        if (inComponent) {\n            if (tag !== `</${current.nodeName}>`) {\n                return\n            } else {\n                inComponent = false\n            }\n        }\n        const isOpen = tag.charAt(1) !== \"/\"\n        const isComment = tag.startsWith(\"<!--\")\n        const start = index + tag.length\n        const nextChar = html.charAt(start)\n        let parent\n\n        if (isComment) {\n            const comment = parseTag(tag)\n\n            // if we're at root, push new base node\n            if (level < 0) {\n                result.push(comment)\n                return result\n            }\n            parent = arr[level]\n            if (parent) {\n                if (!parent.childNodes) {\n                    parent.childNodes = []\n                }\n                parent.childNodes.push(comment)\n            }\n\n            return result\n        }\n\n        if (isOpen) {\n            current = parseTag(tag)\n            level++\n            if (\n                current.type === \"tag\" &&\n                options.components[current.nodeName]\n            ) {\n                current.type = \"component\"\n                inComponent = true\n            }\n\n            if (\n                !current.voidElement &&\n                !inComponent &&\n                nextChar &&\n                nextChar !== \"<\"\n            ) {\n                if (!current.childNodes) {\n                    current.childNodes = []\n                }\n                current.childNodes.push({\n                    nodeName: \"#text\",\n                    data: unescape(html.slice(start, html.indexOf(\"<\", start))),\n                })\n            }\n\n            // if we're at root, push new base node\n            if (level === 0) {\n                result.push(current)\n            }\n\n            parent = arr[level - 1]\n\n            if (parent) {\n                if (!parent.childNodes) {\n                    parent.childNodes = []\n                }\n                parent.childNodes.push(current)\n            }\n\n            arr[level] = current\n        }\n\n        if (!isOpen || current.voidElement) {\n            if (\n                level > -1 &&\n                (current.voidElement ||\n                    current.nodeName === tag.slice(2, -1).toUpperCase())\n            ) {\n                level--\n                // move current up a level to match the end tag\n                current = level === -1 ? result : arr[level]\n            }\n            if (!inComponent && nextChar !== \"<\" && nextChar) {\n                // trailing text node\n                // if we're at the root, push a base text node. otherwise add as\n                // a child to the current node.\n                parent = level === -1 ? result : arr[level].childNodes || []\n\n                // calculate correct end of the data slice in case there's\n                // no tag after the text node.\n                const end = html.indexOf(\"<\", start)\n                let data = unescape(\n                    html.slice(start, end === -1 ? undefined : end)\n                )\n                parent.push({\n                    nodeName: \"#text\",\n                    data,\n                })\n            }\n        }\n    })\n\n    return result[0]\n}\n\nfunction cleanObj(obj) {\n    delete obj.voidElement\n    if (obj.childNodes) {\n        obj.childNodes.forEach((child) => cleanObj(child))\n    }\n    return obj\n}\n\nexport function stringToObj(string) {\n    return cleanObj(parse(string))\n}\n","import {\n    Diff,\n    DiffTracker,\n    cloneObj,\n    getGapInformation,\n    isEqual,\n    markSubTrees,\n    removeDone,\n    roughlyEqual,\n} from \"./helpers\"\nimport { applyVirtual } from \"./apply\"\nimport { nodeToObj } from \"./fromDOM\"\nimport { stringToObj } from \"./fromString\"\n\n// ===== Create a diff =====\n\nexport class DiffFinder {\n    constructor(t1Node, t2Node, options) {\n        this.options = options\n        this.t1 =\n            typeof HTMLElement !== \"undefined\" && t1Node instanceof HTMLElement\n                ? nodeToObj(t1Node, this.options)\n                : typeof t1Node === \"string\"\n                ? stringToObj(t1Node, this.options)\n                : JSON.parse(JSON.stringify(t1Node))\n        this.t2 =\n            typeof HTMLElement !== \"undefined\" && t2Node instanceof HTMLElement\n                ? nodeToObj(t2Node, this.options)\n                : typeof t2Node === \"string\"\n                ? stringToObj(t2Node, this.options)\n                : JSON.parse(JSON.stringify(t2Node))\n        this.diffcount = 0\n        this.foundAll = false\n        if (this.debug) {\n            this.t1Orig = nodeToObj(t1Node, this.options)\n            this.t2Orig = nodeToObj(t2Node, this.options)\n        }\n\n        this.tracker = new DiffTracker()\n    }\n\n    init() {\n        return this.findDiffs(this.t1, this.t2)\n    }\n\n    findDiffs(t1, t2) {\n        let diffs\n        do {\n            if (this.options.debug) {\n                this.diffcount += 1\n                if (this.diffcount > this.options.diffcap) {\n                    throw new Error(\n                        `surpassed diffcap:${JSON.stringify(\n                            this.t1Orig\n                        )} -> ${JSON.stringify(this.t2Orig)}`\n                    )\n                }\n            }\n            diffs = this.findNextDiff(t1, t2, [])\n\n            if (diffs.length === 0) {\n                // Last check if the elements really are the same now.\n                // If not, remove all info about being done and start over.\n                // Sometimes a node can be marked as done, but the creation of subsequent diffs means that it has to be changed again.\n                if (!isEqual(t1, t2)) {\n                    if (this.foundAll) {\n                        console.error(\"Could not find remaining diffs!\")\n                    } else {\n                        this.foundAll = true\n                        removeDone(t1)\n                        diffs = this.findNextDiff(t1, t2, [])\n                    }\n                }\n            }\n            if (diffs.length > 0) {\n                this.foundAll = false\n                this.tracker.add(diffs)\n                applyVirtual(t1, diffs, this.options)\n            }\n        } while (diffs.length > 0)\n\n        return this.tracker.list\n    }\n\n    findNextDiff(t1, t2, route) {\n        let diffs\n        let fdiffs\n\n        if (this.options.maxDepth && route.length > this.options.maxDepth) {\n            return []\n        }\n        // outer differences?\n        if (!t1.outerDone) {\n            diffs = this.findOuterDiff(t1, t2, route)\n            if (this.options.filterOuterDiff) {\n                fdiffs = this.options.filterOuterDiff(t1, t2, diffs)\n                if (fdiffs) diffs = fdiffs\n            }\n            if (diffs.length > 0) {\n                t1.outerDone = true\n                return diffs\n            } else {\n                t1.outerDone = true\n            }\n        }\n        // inner differences?\n        if (!t1.innerDone) {\n            diffs = this.findInnerDiff(t1, t2, route)\n            if (diffs.length > 0) {\n                return diffs\n            } else {\n                t1.innerDone = true\n            }\n        }\n\n        if (this.options.valueDiffing && !t1.valueDone) {\n            // value differences?\n            diffs = this.findValueDiff(t1, t2, route)\n\n            if (diffs.length > 0) {\n                t1.valueDone = true\n                return diffs\n            } else {\n                t1.valueDone = true\n            }\n        }\n\n        // no differences\n        return []\n    }\n\n    findOuterDiff(t1, t2, route) {\n        const diffs = []\n        let attr\n        let attr1\n        let attr2\n        let attrLength\n        let pos\n        let i\n        if (t1.nodeName !== t2.nodeName) {\n            if (!route.length) {\n                throw new Error(\"Top level nodes have to be of the same kind.\")\n            }\n            return [\n                new Diff()\n                    .setValue(\n                        this.options._const.action,\n                        this.options._const.replaceElement\n                    )\n                    .setValue(this.options._const.oldValue, cloneObj(t1))\n                    .setValue(this.options._const.newValue, cloneObj(t2))\n                    .setValue(this.options._const.route, route),\n            ]\n        }\n        if (\n            route.length &&\n            this.options.maxNodeDiffCount <\n                Math.abs(\n                    (t1.childNodes || []).length - (t2.childNodes || []).length\n                )\n        ) {\n            return [\n                new Diff()\n                    .setValue(\n                        this.options._const.action,\n                        this.options._const.replaceElement\n                    )\n                    .setValue(this.options._const.oldValue, cloneObj(t1))\n                    .setValue(this.options._const.newValue, cloneObj(t2))\n                    .setValue(this.options._const.route, route),\n            ]\n        }\n\n        if (t1.data !== t2.data) {\n            // Comment or text node.\n            if (t1.nodeName === \"#text\") {\n                return [\n                    new Diff()\n                        .setValue(\n                            this.options._const.action,\n                            this.options._const.modifyTextElement\n                        )\n                        .setValue(this.options._const.route, route)\n                        .setValue(this.options._const.oldValue, t1.data)\n                        .setValue(this.options._const.newValue, t2.data),\n                ]\n            } else {\n                return [\n                    new Diff()\n                        .setValue(\n                            this.options._const.action,\n                            this.options._const.modifyComment\n                        )\n                        .setValue(this.options._const.route, route)\n                        .setValue(this.options._const.oldValue, t1.data)\n                        .setValue(this.options._const.newValue, t2.data),\n                ]\n            }\n        }\n\n        attr1 = t1.attributes ? Object.keys(t1.attributes).sort() : []\n        attr2 = t2.attributes ? Object.keys(t2.attributes).sort() : []\n\n        attrLength = attr1.length\n        for (i = 0; i < attrLength; i++) {\n            attr = attr1[i]\n            pos = attr2.indexOf(attr)\n            if (pos === -1) {\n                diffs.push(\n                    new Diff()\n                        .setValue(\n                            this.options._const.action,\n                            this.options._const.removeAttribute\n                        )\n                        .setValue(this.options._const.route, route)\n                        .setValue(this.options._const.name, attr)\n                        .setValue(\n                            this.options._const.value,\n                            t1.attributes[attr]\n                        )\n                )\n            } else {\n                attr2.splice(pos, 1)\n                if (t1.attributes[attr] !== t2.attributes[attr]) {\n                    diffs.push(\n                        new Diff()\n                            .setValue(\n                                this.options._const.action,\n                                this.options._const.modifyAttribute\n                            )\n                            .setValue(this.options._const.route, route)\n                            .setValue(this.options._const.name, attr)\n                            .setValue(\n                                this.options._const.oldValue,\n                                t1.attributes[attr]\n                            )\n                            .setValue(\n                                this.options._const.newValue,\n                                t2.attributes[attr]\n                            )\n                    )\n                }\n            }\n        }\n\n        attrLength = attr2.length\n        for (i = 0; i < attrLength; i++) {\n            attr = attr2[i]\n            diffs.push(\n                new Diff()\n                    .setValue(\n                        this.options._const.action,\n                        this.options._const.addAttribute\n                    )\n                    .setValue(this.options._const.route, route)\n                    .setValue(this.options._const.name, attr)\n                    .setValue(this.options._const.value, t2.attributes[attr])\n            )\n        }\n\n        return diffs\n    }\n\n    findInnerDiff(t1, t2, route) {\n        const t1ChildNodes = t1.childNodes ? t1.childNodes.slice() : []\n        const t2ChildNodes = t2.childNodes ? t2.childNodes.slice() : []\n        const last = Math.max(t1ChildNodes.length, t2ChildNodes.length)\n        let childNodesLengthDifference = Math.abs(\n            t1ChildNodes.length - t2ChildNodes.length\n        )\n        let diffs = []\n        let index = 0\n        if (!this.options.maxChildCount || last < this.options.maxChildCount) {\n            const cachedSubtrees = t1.subsets && t1.subsetsAge--\n            const subtrees = cachedSubtrees\n                ? t1.subsets\n                : t1.childNodes && t2.childNodes\n                ? markSubTrees(t1, t2)\n                : []\n            if (subtrees.length > 0) {\n                /* One or more groups have been identified among the childnodes of t1\n                 * and t2.\n                 */\n                diffs = this.attemptGroupRelocation(\n                    t1,\n                    t2,\n                    subtrees,\n                    route,\n                    cachedSubtrees\n                )\n                if (diffs.length > 0) {\n                    return diffs\n                }\n            }\n        }\n\n        /* 0 or 1 groups of similar child nodes have been found\n         * for t1 and t2. 1 If there is 1, it could be a sign that the\n         * contents are the same. When the number of groups is below 2,\n         * t1 and t2 are made to have the same length and each of the\n         * pairs of child nodes are diffed.\n         */\n\n        for (let i = 0; i < last; i += 1) {\n            const e1 = t1ChildNodes[i]\n            const e2 = t2ChildNodes[i]\n\n            if (childNodesLengthDifference) {\n                /* t1 and t2 have different amounts of childNodes. Add\n                 * and remove as necessary to obtain the same length */\n                if (e1 && !e2) {\n                    if (e1.nodeName === \"#text\") {\n                        diffs.push(\n                            new Diff()\n                                .setValue(\n                                    this.options._const.action,\n                                    this.options._const.removeTextElement\n                                )\n                                .setValue(\n                                    this.options._const.route,\n                                    route.concat(index)\n                                )\n                                .setValue(this.options._const.value, e1.data)\n                        )\n                        index -= 1\n                    } else {\n                        diffs.push(\n                            new Diff()\n                                .setValue(\n                                    this.options._const.action,\n                                    this.options._const.removeElement\n                                )\n                                .setValue(\n                                    this.options._const.route,\n                                    route.concat(index)\n                                )\n                                .setValue(\n                                    this.options._const.element,\n                                    cloneObj(e1)\n                                )\n                        )\n                        index -= 1\n                    }\n                } else if (e2 && !e1) {\n                    if (e2.nodeName === \"#text\") {\n                        diffs.push(\n                            new Diff()\n                                .setValue(\n                                    this.options._const.action,\n                                    this.options._const.addTextElement\n                                )\n                                .setValue(\n                                    this.options._const.route,\n                                    route.concat(index)\n                                )\n                                .setValue(this.options._const.value, e2.data)\n                        )\n                    } else {\n                        diffs.push(\n                            new Diff()\n                                .setValue(\n                                    this.options._const.action,\n                                    this.options._const.addElement\n                                )\n                                .setValue(\n                                    this.options._const.route,\n                                    route.concat(index)\n                                )\n                                .setValue(\n                                    this.options._const.element,\n                                    cloneObj(e2)\n                                )\n                        )\n                    }\n                }\n            }\n            /* We are now guaranteed that childNodes e1 and e2 exist,\n             * and that they can be diffed.\n             */\n            /* Diffs in child nodes should not affect the parent node,\n             * so we let these diffs be submitted together with other\n             * diffs.\n             */\n\n            if (e1 && e2) {\n                if (\n                    !this.options.maxChildCount ||\n                    last < this.options.maxChildCount\n                ) {\n                    diffs = diffs.concat(\n                        this.findNextDiff(e1, e2, route.concat(index))\n                    )\n                } else if (!isEqual(e1, e2)) {\n                    if (t1ChildNodes.length > t2ChildNodes.length) {\n                        if (e1.nodeName === \"#text\") {\n                            diffs.push(\n                                new Diff()\n                                    .setValue(\n                                        this.options._const.action,\n                                        this.options._const.removeTextElement\n                                    )\n                                    .setValue(\n                                        this.options._const.route,\n                                        route.concat(index)\n                                    )\n                                    .setValue(\n                                        this.options._const.value,\n                                        e1.data\n                                    )\n                            )\n                        } else {\n                            diffs.push(\n                                new Diff()\n                                    .setValue(\n                                        this.options._const.action,\n                                        this.options._const.removeElement\n                                    )\n                                    .setValue(\n                                        this.options._const.element,\n                                        cloneObj(e1)\n                                    )\n                                    .setValue(\n                                        this.options._const.route,\n                                        route.concat(index)\n                                    )\n                            )\n                        }\n                        t1ChildNodes.splice(i, 1)\n                        i -= 1\n                        index -= 1\n\n                        childNodesLengthDifference -= 1\n                    } else if (t1ChildNodes.length < t2ChildNodes.length) {\n                        diffs = diffs.concat([\n                            new Diff()\n                                .setValue(\n                                    this.options._const.action,\n                                    this.options._const.addElement\n                                )\n                                .setValue(\n                                    this.options._const.element,\n                                    cloneObj(e2)\n                                )\n                                .setValue(\n                                    this.options._const.route,\n                                    route.concat(index)\n                                ),\n                        ])\n                        t1ChildNodes.splice(i, 0, {})\n                        childNodesLengthDifference -= 1\n                    } else {\n                        diffs = diffs.concat([\n                            new Diff()\n                                .setValue(\n                                    this.options._const.action,\n                                    this.options._const.replaceElement\n                                )\n                                .setValue(\n                                    this.options._const.oldValue,\n                                    cloneObj(e1)\n                                )\n                                .setValue(\n                                    this.options._const.newValue,\n                                    cloneObj(e2)\n                                )\n                                .setValue(\n                                    this.options._const.route,\n                                    route.concat(index)\n                                ),\n                        ])\n                    }\n                }\n            }\n            index += 1\n        }\n        t1.innerDone = true\n        return diffs\n    }\n\n    attemptGroupRelocation(t1, t2, subtrees, route, cachedSubtrees) {\n        /* Either t1.childNodes and t2.childNodes have the same length, or\n         * there are at least two groups of similar elements can be found.\n         * attempts are made at equalizing t1 with t2. First all initial\n         * elements with no group affiliation (gaps=true) are removed (if\n         * only in t1) or added (if only in t2). Then the creation of a group\n         * relocation diff is attempted.\n         */\n        const gapInformation = getGapInformation(t1, t2, subtrees)\n        const gaps1 = gapInformation.gaps1\n        const gaps2 = gapInformation.gaps2\n        let shortest = Math.min(gaps1.length, gaps2.length)\n        let destinationDifferent\n        let toGroup\n        let group\n        let node\n        let similarNode\n        let testI\n        const diffs = []\n\n        for (\n            let index2 = 0, index1 = 0;\n            index2 < shortest;\n            index1 += 1, index2 += 1\n        ) {\n            if (\n                cachedSubtrees &&\n                (gaps1[index2] === true || gaps2[index2] === true)\n            ) {\n                // pass\n            } else if (gaps1[index2] === true) {\n                node = t1.childNodes[index1]\n                if (node.nodeName === \"#text\") {\n                    if (t2.childNodes[index2].nodeName === \"#text\") {\n                        if (node.data !== t2.childNodes[index2].data) {\n                            testI = index1\n                            while (\n                                t1.childNodes.length > testI + 1 &&\n                                t1.childNodes[testI + 1].nodeName === \"#text\"\n                            ) {\n                                testI += 1\n                                if (\n                                    t2.childNodes[index2].data ===\n                                    t1.childNodes[testI].data\n                                ) {\n                                    similarNode = true\n                                    break\n                                }\n                            }\n                            if (!similarNode) {\n                                diffs.push(\n                                    new Diff()\n                                        .setValue(\n                                            this.options._const.action,\n                                            this.options._const\n                                                .modifyTextElement\n                                        )\n                                        .setValue(\n                                            this.options._const.route,\n                                            route.concat(index2)\n                                        )\n                                        .setValue(\n                                            this.options._const.oldValue,\n                                            node.data\n                                        )\n                                        .setValue(\n                                            this.options._const.newValue,\n                                            t2.childNodes[index2].data\n                                        )\n                                )\n                                return diffs\n                            }\n                        }\n                    } else {\n                        diffs.push(\n                            new Diff()\n                                .setValue(\n                                    this.options._const.action,\n                                    this.options._const.removeTextElement\n                                )\n                                .setValue(\n                                    this.options._const.route,\n                                    route.concat(index2)\n                                )\n                                .setValue(this.options._const.value, node.data)\n                        )\n                        gaps1.splice(index2, 1)\n                        shortest = Math.min(gaps1.length, gaps2.length)\n                        index2 -= 1\n                    }\n                } else {\n                    diffs.push(\n                        new Diff()\n                            .setValue(\n                                this.options._const.action,\n                                this.options._const.removeElement\n                            )\n                            .setValue(\n                                this.options._const.route,\n                                route.concat(index2)\n                            )\n                            .setValue(\n                                this.options._const.element,\n                                cloneObj(node)\n                            )\n                    )\n                    gaps1.splice(index2, 1)\n                    shortest = Math.min(gaps1.length, gaps2.length)\n                    index2 -= 1\n                }\n            } else if (gaps2[index2] === true) {\n                node = t2.childNodes[index2]\n                if (node.nodeName === \"#text\") {\n                    diffs.push(\n                        new Diff()\n                            .setValue(\n                                this.options._const.action,\n                                this.options._const.addTextElement\n                            )\n                            .setValue(\n                                this.options._const.route,\n                                route.concat(index2)\n                            )\n                            .setValue(this.options._const.value, node.data)\n                    )\n                    gaps1.splice(index2, 0, true)\n                    shortest = Math.min(gaps1.length, gaps2.length)\n                    index1 -= 1\n                } else {\n                    diffs.push(\n                        new Diff()\n                            .setValue(\n                                this.options._const.action,\n                                this.options._const.addElement\n                            )\n                            .setValue(\n                                this.options._const.route,\n                                route.concat(index2)\n                            )\n                            .setValue(\n                                this.options._const.element,\n                                cloneObj(node)\n                            )\n                    )\n                    gaps1.splice(index2, 0, true)\n                    shortest = Math.min(gaps1.length, gaps2.length)\n                    index1 -= 1\n                }\n            } else if (gaps1[index2] !== gaps2[index2]) {\n                if (diffs.length > 0) {\n                    return diffs\n                }\n                // group relocation\n                group = subtrees[gaps1[index2]]\n                toGroup = Math.min(\n                    group.newValue,\n                    t1.childNodes.length - group.length\n                )\n                if (toGroup !== group.oldValue) {\n                    // Check whether destination nodes are different than originating ones.\n                    destinationDifferent = false\n                    for (let j = 0; j < group.length; j += 1) {\n                        if (\n                            !roughlyEqual(\n                                t1.childNodes[toGroup + j],\n                                t1.childNodes[group.oldValue + j],\n                                [],\n                                false,\n                                true\n                            )\n                        ) {\n                            destinationDifferent = true\n                        }\n                    }\n                    if (destinationDifferent) {\n                        return [\n                            new Diff()\n                                .setValue(\n                                    this.options._const.action,\n                                    this.options._const.relocateGroup\n                                )\n                                .setValue(\"groupLength\", group.length)\n                                .setValue(\n                                    this.options._const.from,\n                                    group.oldValue\n                                )\n                                .setValue(this.options._const.to, toGroup)\n                                .setValue(this.options._const.route, route),\n                        ]\n                    }\n                }\n            }\n        }\n        return diffs\n    }\n\n    findValueDiff(t1, t2, route) {\n        // Differences of value. Only useful if the value/selection/checked value\n        // differs from what is represented in the DOM. For example in the case\n        // of filled out forms, etc.\n        const diffs = []\n\n        if (t1.selected !== t2.selected) {\n            diffs.push(\n                new Diff()\n                    .setValue(\n                        this.options._const.action,\n                        this.options._const.modifySelected\n                    )\n                    .setValue(this.options._const.oldValue, t1.selected)\n                    .setValue(this.options._const.newValue, t2.selected)\n                    .setValue(this.options._const.route, route)\n            )\n        }\n\n        if (\n            (t1.value || t2.value) &&\n            t1.value !== t2.value &&\n            t1.nodeName !== \"OPTION\"\n        ) {\n            diffs.push(\n                new Diff()\n                    .setValue(\n                        this.options._const.action,\n                        this.options._const.modifyValue\n                    )\n                    .setValue(this.options._const.oldValue, t1.value || \"\")\n                    .setValue(this.options._const.newValue, t2.value || \"\")\n                    .setValue(this.options._const.route, route)\n            )\n        }\n        if (t1.checked !== t2.checked) {\n            diffs.push(\n                new Diff()\n                    .setValue(\n                        this.options._const.action,\n                        this.options._const.modifyChecked\n                    )\n                    .setValue(this.options._const.oldValue, t1.checked)\n                    .setValue(this.options._const.newValue, t2.checked)\n                    .setValue(this.options._const.route, route)\n            )\n        }\n\n        return diffs\n    }\n}\n","import { applyDOM, undoDOM } from \"./dom/index\"\nimport { DiffFinder } from \"./virtual/index\"\nexport { nodeToObj, stringToObj } from \"./virtual/index\"\n\nconst DEFAULT_OPTIONS = {\n    debug: false,\n    diffcap: 10, // Limit for how many diffs are accepting when debugging. Inactive when debug is false.\n    maxDepth: false, // False or a numeral. If set to a numeral, limits the level of depth that the the diff mechanism looks for differences. If false, goes through the entire tree.\n    maxChildCount: 50, // False or a numeral. If set to a numeral, only does a simplified form of diffing of contents so that the number of diffs cannot be higher than the number of child nodes.\n    valueDiffing: true, // Whether to take into consideration the values of forms that differ from auto assigned values (when a user fills out a form).\n    // syntax: textDiff: function (node, currentValue, expectedValue, newValue)\n    textDiff(node, currentValue, expectedValue, newValue) {\n        node.data = newValue\n        return\n    },\n    // empty functions were benchmarked as running faster than both\n    // `f && f()` and `if (f) { f(); }`\n    preVirtualDiffApply() {},\n    postVirtualDiffApply() {},\n    preDiffApply() {},\n    postDiffApply() {},\n    filterOuterDiff: null,\n    compress: false, // Whether to work with compressed diffs\n    _const: false, // object with strings for every change types to be used in diffs.\n    document:\n        typeof window !== \"undefined\" && window.document\n            ? window.document\n            : false,\n}\n\nexport class DiffDOM {\n    constructor(options = {}) {\n        this.options = options\n        // IE11 doesn't have Object.assign and buble doesn't translate object spreaders\n        // by default, so this is the safest way of doing it currently.\n        Object.entries(DEFAULT_OPTIONS).forEach(([key, value]) => {\n            if (!Object.prototype.hasOwnProperty.call(this.options, key)) {\n                this.options[key] = value\n            }\n        })\n\n        if (!this.options._const) {\n            const varNames = [\n                \"addAttribute\",\n                \"modifyAttribute\",\n                \"removeAttribute\",\n                \"modifyTextElement\",\n                \"relocateGroup\",\n                \"removeElement\",\n                \"addElement\",\n                \"removeTextElement\",\n                \"addTextElement\",\n                \"replaceElement\",\n                \"modifyValue\",\n                \"modifyChecked\",\n                \"modifySelected\",\n                \"modifyComment\",\n                \"action\",\n                \"route\",\n                \"oldValue\",\n                \"newValue\",\n                \"element\",\n                \"group\",\n                \"from\",\n                \"to\",\n                \"name\",\n                \"value\",\n                \"data\",\n                \"attributes\",\n                \"nodeName\",\n                \"childNodes\",\n                \"checked\",\n                \"selected\",\n            ]\n            this.options._const = {}\n            if (this.options.compress) {\n                varNames.forEach(\n                    (varName, index) => (this.options._const[varName] = index)\n                )\n            } else {\n                varNames.forEach(\n                    (varName) => (this.options._const[varName] = varName)\n                )\n            }\n        }\n\n        this.DiffFinder = DiffFinder\n    }\n\n    apply(tree, diffs) {\n        return applyDOM(tree, diffs, this.options)\n    }\n\n    undo(tree, diffs) {\n        return undoDOM(tree, diffs, this.options)\n    }\n\n    diff(t1Node, t2Node) {\n        const finder = new this.DiffFinder(t1Node, t2Node, this.options)\n        return finder.init()\n    }\n}\n","/**\n * Use TraceLogger to figure out function calls inside\n * JS objects by wrapping an object with a TraceLogger\n * instance.\n *\n * Pretty-prints the call trace (using unicode box code)\n * when tracelogger.toString() is called.\n */\n\n/**\n * Wrap an object by calling new TraceLogger(obj)\n *\n * If you're familiar with Python decorators, this\n * does roughly the same thing, adding pre/post\n * call hook logging calls so that you can see\n * what's going on.\n */\nexport class TraceLogger {\n    constructor(obj = {}) {\n        this.pad = \"   \"\n        this.padding = \"\"\n        this.tick = 1\n        this.messages = []\n        const wrapkey = (obj, key) => {\n            // trace this function\n            const oldfn = obj[key]\n            obj[key] = (...args) => {\n                this.fin(key, Array.prototype.slice.call(args))\n                const result = oldfn.apply(obj, args)\n                this.fout(key, result)\n                return result\n            }\n        }\n        // can't use Object.keys for prototype walking\n        for (let key in obj) {\n            if (typeof obj[key] === \"function\") {\n                wrapkey(obj, key)\n            }\n        }\n        this.log(\" TRACELOG START\")\n    }\n    // called when entering a function\n    fin(fn, args) {\n        this.padding += this.pad\n        this.log(`> entering ${fn}`, args)\n    }\n    // called when exiting a function\n    fout(fn, result) {\n        this.log(\"< generated return value\", result)\n        this.padding = this.padding.substring(\n            0,\n            this.padding.length - this.pad.length\n        )\n    }\n    // log message formatting\n    format(s, tick) {\n        let nf = function (t) {\n            t = `${t}`\n            while (t.length < 4) {\n                t = `0${t}`\n            }\n            return t\n        }\n        return `${nf(tick)}> ${this.padding}${s}`\n    }\n    // log a trace message\n    log() {\n        let s = Array.prototype.slice.call(arguments)\n        const stringCollapse = function (v) {\n            if (!v) {\n                return \"<falsey>\"\n            }\n            if (typeof v === \"string\") {\n                return v\n            }\n            if (v instanceof HTMLElement) {\n                return v.outerHTML || \"<empty>\"\n            }\n            if (v instanceof Array) {\n                return `[${v.map(stringCollapse).join(\",\")}]`\n            }\n            return v.toString() || v.valueOf() || \"<unknown>\"\n        }\n        s = s.map(stringCollapse).join(\", \")\n        this.messages.push(this.format(s, this.tick++))\n    }\n    // turn the log into a structured string with\n    // unicode box codes to make it a sensible trace.\n    toString() {\n        let cap = \"   \"\n        let terminator = \"\"\n        while (terminator.length <= this.padding.length + this.pad.length) {\n            terminator += cap\n        }\n        let _ = this.padding\n        this.padding = \"\"\n        terminator = this.format(terminator, this.tick)\n        this.padding = _\n        return `${this.messages.join(\"\\n\")}\\n${terminator}`\n    }\n}\n"],"names":["objToNode","objNode","insideSvg","options","let","node","nodeName","document","createTextNode","data","createComment","createElementNS","toLowerCase","createElement","attributes","Object","entries","forEach","ref","key","setAttribute","value","childNodes","childNode","appendChild","valueDiffing","checked","selected","getFromRoute","route","slice","length","const","c","splice","applyDiff","tree","diff","newNode","reference","_const","info","preDiffApply","action","addAttribute","name","modifyAttribute","newValue","removeAttribute","modifyTextElement","nodeType","textDiff","oldValue","modifyValue","modifyComment","modifyChecked","modifySelected","replaceElement","parentNode","replaceChild","relocateGroup","Array","apply","groupLength","map","removeChild","from","index","to","insertBefore","removeElement","addElement","element","namespaceURI","removeTextElement","addTextElement","console","log","postDiffApply","swap","obj","p1","p2","tmp","undoDOM","diffs","reverse","undoDiff","Diff","this","elementDescriptors","el","output","push","replace","id","findUniqueDescriptors","li","uniqueDescriptors","duplicateDescriptors","descriptor","inUnique","uniqueInBoth","l1","l2","l1Unique","l2Unique","inBoth","keys","removeDone","outerDone","innerDone","valueDone","every","isEqual","e1","e2","Boolean","e1Attributes","e2Attributes","attribute","roughlyEqual","sameSiblings","preventRecursion","nodeList1","nodeList2","childUniqueDescriptors","cloneObj","JSON","parse","stringify","findCommonSubsets","c1","c2","marked1","marked2","lcsSize","c1Length","c2Length","matches","subsetsSame","some","i","c1Desc","c2Desc","description","c1Index","c1Element","c2Index","c2Element","makeArray","n","v","prototype","toString","setValue","aKey","aValue","DiffTracker","list","getFromVirtualRoute","nodeIndex","applyVirtual","routeInfo","newSubsets","preVirtualDiffApply","movedNode","subsets","splitLength","delete","filter","concat","postVirtualDiffApply","applyVirtualDiff","nodeToObj","aNode","call","undefined","type","includes","add","fn","tagRE","empty","create","attrRE","unescape","string","lookup","area","base","br","col","embed","hr","img","input","keygen","link","menuItem","meta","param","source","track","wbr","parseTag","tag","res","tagMatch","match","toUpperCase","charAt","voidElement","startsWith","endIndex","indexOf","reg","RegExp","result","done","exec","trim","attr","arr","split","lastIndex","substring","cleanObj","child","stringToObj","html","components","current","level","inComponent","end","parent","isOpen","isComment","start","nextChar","comment","DiffFinder","t1Node","t2Node","t1","HTMLElement","t2","diffcount","foundAll","debug","t1Orig","t2Orig","tracker","init","findDiffs","diffcap","Error","findNextDiff","error","fdiffs","maxDepth","findOuterDiff","filterOuterDiff","findInnerDiff","findValueDiff","attr1","attr2","attrLength","pos","maxNodeDiffCount","Math","abs","sort","t1ChildNodes","t2ChildNodes","last","max","childNodesLengthDifference","maxChildCount","cachedSubtrees","subsetsAge","subtrees","oldTree","newTree","oldChildren","newChildren","subset","returnIndex","arguments","item","markSubTrees","attemptGroupRelocation","destinationDifferent","toGroup","group","similarNode","testI","gapInformation","stable","gaps1","gaps2","endOld","endNew","j","getGapInformation","shortest","min","index2","index1","DEFAULT_OPTIONS","currentValue","expectedValue","compress","window","DiffDOM","hasOwnProperty","varNames","varName","applyDOM","undo","TraceLogger","pad","padding","tick","messages","wrapkey","oldfn","fin","args","fout","format","s","t","stringCollapse","outerHTML","join","valueOf","terminator","_"],"mappings":"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"}