{"version":3,"file":"diffDOM.js","sources":["../node_modules/tslib/tslib.es6.js","../src/diffDOM/helpers.ts","../src/diffDOM/dom/fromVirtual.ts","../src/diffDOM/dom/apply.ts","../src/diffDOM/dom/undo.ts","../src/diffDOM/virtual/helpers.ts","../src/diffDOM/virtual/apply.ts","../src/diffDOM/virtual/fromDOM.ts","../src/diffDOM/virtual/fromString.ts","../src/diffDOM/virtual/diff.ts","../src/diffDOM/index.ts","../src/TraceLogger.ts"],"sourcesContent":["/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise, SuppressedError, Symbol */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\r\n    function accept(f) { if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\"); return f; }\r\n    var kind = contextIn.kind, key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\r\n    var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\r\n    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\r\n    var _, done = false;\r\n    for (var i = decorators.length - 1; i >= 0; i--) {\r\n        var context = {};\r\n        for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\r\n        for (var p in contextIn.access) context.access[p] = contextIn.access[p];\r\n        context.addInitializer = function (f) { if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\"); extraInitializers.push(accept(f || null)); };\r\n        var result = (0, decorators[i])(kind === \"accessor\" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);\r\n        if (kind === \"accessor\") {\r\n            if (result === void 0) continue;\r\n            if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\r\n            if (_ = accept(result.get)) descriptor.get = _;\r\n            if (_ = accept(result.set)) descriptor.set = _;\r\n            if (_ = accept(result.init)) initializers.unshift(_);\r\n        }\r\n        else if (_ = accept(result)) {\r\n            if (kind === \"field\") initializers.unshift(_);\r\n            else descriptor[key] = _;\r\n        }\r\n    }\r\n    if (target) Object.defineProperty(target, contextIn.name, descriptor);\r\n    done = true;\r\n};\r\n\r\nexport function __runInitializers(thisArg, initializers, value) {\r\n    var useValue = arguments.length > 2;\r\n    for (var i = 0; i < initializers.length; i++) {\r\n        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\r\n    }\r\n    return useValue ? value : void 0;\r\n};\r\n\r\nexport function __propKey(x) {\r\n    return typeof x === \"symbol\" ? x : \"\".concat(x);\r\n};\r\n\r\nexport function __setFunctionName(f, name, prefix) {\r\n    if (typeof name === \"symbol\") name = name.description ? \"[\".concat(name.description, \"]\") : \"\";\r\n    return Object.defineProperty(f, \"name\", { configurable: true, value: prefix ? \"\".concat(prefix, \" \", name) : name });\r\n};\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n        desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nexport function __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n\r\nexport function __classPrivateFieldIn(state, receiver) {\r\n    if (receiver === null || (typeof receiver !== \"object\" && typeof receiver !== \"function\")) throw new TypeError(\"Cannot use 'in' operator on non-object\");\r\n    return typeof state === \"function\" ? receiver === state : state.has(receiver);\r\n}\r\n\r\nexport function __addDisposableResource(env, value, async) {\r\n    if (value !== null && value !== void 0) {\r\n        if (typeof value !== \"object\" && typeof value !== \"function\") throw new TypeError(\"Object expected.\");\r\n        var dispose;\r\n        if (async) {\r\n            if (!Symbol.asyncDispose) throw new TypeError(\"Symbol.asyncDispose is not defined.\");\r\n            dispose = value[Symbol.asyncDispose];\r\n        }\r\n        if (dispose === void 0) {\r\n            if (!Symbol.dispose) throw new TypeError(\"Symbol.dispose is not defined.\");\r\n            dispose = value[Symbol.dispose];\r\n        }\r\n        if (typeof dispose !== \"function\") throw new TypeError(\"Object not disposable.\");\r\n        env.stack.push({ value: value, dispose: dispose, async: async });\r\n    }\r\n    else if (async) {\r\n        env.stack.push({ async: true });\r\n    }\r\n    return value;\r\n}\r\n\r\nvar _SuppressedError = typeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\r\n    var e = new Error(message);\r\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\r\n};\r\n\r\nexport function __disposeResources(env) {\r\n    function fail(e) {\r\n        env.error = env.hasError ? new _SuppressedError(e, env.error, \"An error was suppressed during disposal.\") : e;\r\n        env.hasError = true;\r\n    }\r\n    function next() {\r\n        while (env.stack.length) {\r\n            var rec = env.stack.pop();\r\n            try {\r\n                var result = rec.dispose && rec.dispose.call(rec.value);\r\n                if (rec.async) return Promise.resolve(result).then(next, function(e) { fail(e); return next(); });\r\n            }\r\n            catch (e) {\r\n                fail(e);\r\n            }\r\n        }\r\n        if (env.hasError) throw env.error;\r\n    }\r\n    return next();\r\n}\r\n\r\nexport default {\r\n    __extends: __extends,\r\n    __assign: __assign,\r\n    __rest: __rest,\r\n    __decorate: __decorate,\r\n    __param: __param,\r\n    __metadata: __metadata,\r\n    __awaiter: __awaiter,\r\n    __generator: __generator,\r\n    __createBinding: __createBinding,\r\n    __exportStar: __exportStar,\r\n    __values: __values,\r\n    __read: __read,\r\n    __spread: __spread,\r\n    __spreadArrays: __spreadArrays,\r\n    __spreadArray: __spreadArray,\r\n    __await: __await,\r\n    __asyncGenerator: __asyncGenerator,\r\n    __asyncDelegator: __asyncDelegator,\r\n    __asyncValues: __asyncValues,\r\n    __makeTemplateObject: __makeTemplateObject,\r\n    __importStar: __importStar,\r\n    __importDefault: __importDefault,\r\n    __classPrivateFieldGet: __classPrivateFieldGet,\r\n    __classPrivateFieldSet: __classPrivateFieldSet,\r\n    __classPrivateFieldIn: __classPrivateFieldIn,\r\n    __addDisposableResource: __addDisposableResource,\r\n    __disposeResources: __disposeResources,\r\n};\r\n","import { elementNodeType } from \"./types\"\n\nexport class Diff {\n    constructor(options = {}) {\n        Object.entries(options).forEach(([key, value]) => (this[key] = value))\n    }\n\n    toString() {\n        return JSON.stringify(this)\n    }\n\n    setValue(\n        aKey: string | number,\n        aValue:\n            | string\n            | number\n            | boolean\n            | number[]\n            | { [key: string]: string | { [key: string]: string } }\n            | elementNodeType,\n    ) {\n        this[aKey] = aValue\n        return this\n    }\n}\n\n/**\n * Checks if an element is of a certain type using direct property checking or DOM instanceof\n * \n * @param element The element to check\n * @param elementTypeNames The element type names to check against\n * @param simplifiedCheck If true, uses simplified checking based on nodeName/nodeType\n * @returns boolean indicating if the element matches any of the specified types\n */\nexport function checkElementType(element, simplifiedCheck = false, ...elementTypeNames: string[]) {\n    if (typeof element === \"undefined\" || element === null) {\n        return false\n    }\n\n    // Simplified check for primitive virtual DOMs without ownerDocument\n    if (simplifiedCheck) {\n        return elementTypeNames.some((elementTypeName) => {\n            // Special case for basic element types\n            if (elementTypeName === \"Element\") {\n                return element.nodeType === 1 || \n                       (typeof element.nodeName === \"string\" && \n                        element.nodeName !== \"#text\" && \n                        element.nodeName !== \"#comment\");\n            }\n            if (elementTypeName === \"Text\") {\n                return element.nodeType === 3 || \n                       element.nodeName === \"#text\";\n            }\n            if (elementTypeName === \"Comment\") {\n                return element.nodeType === 8 || \n                       element.nodeName === \"#comment\";\n            }\n            \n            // For HTML element types, check nodeName\n            if (elementTypeName.startsWith(\"HTML\") && elementTypeName.endsWith(\"Element\")) {\n                const tagName = elementTypeName.slice(4, -7).toLowerCase();\n                return (element.nodeName && element.nodeName.toLowerCase() === tagName);\n            }\n            \n            return false;\n        });\n    }\n    \n    // Original DOM-based check\n    return elementTypeNames.some(\n        (elementTypeName) =>\n            // We need to check if the specified type is defined\n            // because otherwise instanceof throws an exception.\n            typeof element?.ownerDocument?.defaultView?.[elementTypeName] ===\n                \"function\" &&\n            element instanceof\n                element.ownerDocument.defaultView[elementTypeName],\n    )\n}\n","import { DiffDOMOptions, elementNodeType, textNodeType } from \"../types\"\nimport { checkElementType } from \"../helpers\"\n\nexport function objToNode(\n    objNode: elementNodeType,\n    insideSvg: boolean,\n    options: DiffDOMOptions,\n) {\n    let node: Element | Text | Comment\n    if (objNode.nodeName === \"#text\") {\n        node = options.document.createTextNode((objNode as textNodeType).data)\n    } else if (objNode.nodeName === \"#comment\") {\n        node = options.document.createComment((objNode as textNodeType).data)\n    } else {\n        if (insideSvg) {\n            node = options.document.createElementNS(\n                \"http://www.w3.org/2000/svg\",\n                objNode.nodeName,\n            )\n            if (objNode.nodeName === \"foreignObject\") {\n                insideSvg = false\n            }\n        } else if (objNode.nodeName.toLowerCase() === \"svg\") {\n            node = options.document.createElementNS(\n                \"http://www.w3.org/2000/svg\",\n                \"svg\",\n            )\n            insideSvg = true\n        } else {\n            node = options.document.createElement(objNode.nodeName)\n        }\n        if (objNode.attributes) {\n            Object.entries(objNode.attributes).forEach(([key, value]) =>\n                (node as Element).setAttribute(key, value),\n            )\n        }\n        if (objNode.childNodes) {\n            node = node as Element\n            objNode.childNodes.forEach(\n                (childNode: elementNodeType | textNodeType) =>\n                    node.appendChild(objToNode(childNode, insideSvg, options)),\n            )\n        }\n        if (options.valueDiffing) {\n            if (\n                objNode.value &&\n                checkElementType(\n                    node,\n                    options.simplifiedElementCheck,\n                    \"HTMLButtonElement\",\n                    \"HTMLDataElement\",\n                    \"HTMLInputElement\",\n                    \"HTMLLIElement\",\n                    \"HTMLMeterElement\",\n                    \"HTMLOptionElement\",\n                    \"HTMLProgressElement\",\n                    \"HTMLParamElement\",\n                )\n            ) {\n                ;(\n                    node as\n                        | HTMLButtonElement\n                        | HTMLDataElement\n                        | HTMLInputElement\n                        | HTMLLIElement\n                        | HTMLMeterElement\n                        | HTMLOptionElement\n                        | HTMLProgressElement\n                        | HTMLParamElement\n                ).value = objNode.value\n            }\n            if (objNode.checked && checkElementType(node, options.simplifiedElementCheck, \"HTMLInputElement\")) {\n                ;(node as HTMLInputElement).checked = objNode.checked\n            }\n            if (\n                objNode.selected &&\n                checkElementType(node, options.simplifiedElementCheck, \"HTMLOptionElement\")\n            ) {\n                ;(node as HTMLOptionElement).selected = objNode.selected\n            }\n        }\n    }\n    return node\n}\n","import { DiffDOMOptions, diffType, nodeType } from \"../types\"\nimport { Diff, checkElementType } from \"../helpers\"\n\nimport { objToNode } from \"./fromVirtual\"\n\n// ===== Apply a diff =====\n\nconst getFromRoute = (\n    node: Element,\n    route: number[],\n): Element | Text | false => {\n    route = route.slice()\n    while (route.length > 0) {\n        const c = route.splice(0, 1)[0]\n        node = node.childNodes[c] as Element\n    }\n    return node\n}\n\nexport function applyDiff(\n    tree: Element,\n    diff: diffType,\n    options: DiffDOMOptions, // {preDiffApply, postDiffApply, textDiff, valueDiffing, _const}\n) {\n    const action = diff[options._const.action] as string | number\n    const route = diff[options._const.route] as number[]\n    let node\n\n    if (\n        ![options._const.addElement, options._const.addTextElement].includes(\n            action,\n        )\n    ) {\n        // For adding nodes, we calculate the route later on. It's different because it includes the position of the newly added item.\n        node = getFromRoute(tree, route)\n    }\n\n    let newNode\n    let reference: Element\n    let nodeArray\n\n    // pre-diff hook\n    const info = {\n        diff,\n        node,\n    }\n\n    if (options.preDiffApply(info)) {\n        return true\n    }\n\n    switch (action) {\n        case options._const.addAttribute:\n            if (!node || !checkElementType(node, options.simplifiedElementCheck, \"Element\")) {\n                return false\n            }\n            node.setAttribute(\n                diff[options._const.name] as string,\n                diff[options._const.value] as string,\n            )\n            break\n        case options._const.modifyAttribute:\n            if (!node || !checkElementType(node, options.simplifiedElementCheck, \"Element\")) {\n                return false\n            }\n            node.setAttribute(\n                diff[options._const.name] as string,\n                diff[options._const.newValue] as string,\n            )\n            if (\n                checkElementType(node, options.simplifiedElementCheck, \"HTMLInputElement\") &&\n                diff[options._const.name] === \"value\"\n            ) {\n                node.value = diff[options._const.newValue] as string\n            }\n            break\n        case options._const.removeAttribute:\n            if (!node || !checkElementType(node, options.simplifiedElementCheck, \"Element\")) {\n                return false\n            }\n            node.removeAttribute(diff[options._const.name] as string)\n            break\n        case options._const.modifyTextElement:\n            if (!node || !checkElementType(node, options.simplifiedElementCheck, \"Text\")) {\n                return false\n            }\n            options.textDiff(\n                node,\n                node.data,\n                diff[options._const.oldValue] as string,\n                diff[options._const.newValue] as string,\n            )\n            if (checkElementType(node.parentNode, options.simplifiedElementCheck, \"HTMLTextAreaElement\")) {\n                node.parentNode.value = diff[options._const.newValue] as string\n            }\n            break\n        case options._const.modifyValue:\n            if (!node || typeof node.value === \"undefined\") {\n                return false\n            }\n            node.value = diff[options._const.newValue]\n            break\n        case options._const.modifyComment:\n            if (!node || !checkElementType(node, options.simplifiedElementCheck, \"Comment\")) {\n                return false\n            }\n            options.textDiff(\n                node,\n                node.data,\n                diff[options._const.oldValue] as string,\n                diff[options._const.newValue] as string,\n            )\n            break\n        case options._const.modifyChecked:\n            if (!node || typeof node.checked === \"undefined\") {\n                return false\n            }\n            node.checked = diff[options._const.newValue]\n            break\n        case options._const.modifySelected:\n            if (!node || typeof node.selected === \"undefined\") {\n                return false\n            }\n            node.selected = diff[options._const.newValue]\n            break\n        case options._const.replaceElement: {\n            const insideSvg =\n                (\n                    diff[options._const.newValue] as nodeType\n                ).nodeName.toLowerCase() === \"svg\" ||\n                node.parentNode.namespaceURI === \"http://www.w3.org/2000/svg\"\n            node.parentNode.replaceChild(\n                objToNode(\n                    diff[options._const.newValue] as nodeType,\n                    insideSvg,\n                    options,\n                ),\n                node,\n            )\n            break\n        }\n        case options._const.relocateGroup:\n            nodeArray = [...new Array(diff[options._const.groupLength])].map(\n                () =>\n                    node.removeChild(\n                        node.childNodes[diff[options._const.from] as number],\n                    ),\n            )\n            nodeArray.forEach((childNode, index) => {\n                if (index === 0) {\n                    reference =\n                        node.childNodes[diff[options._const.to] as number]\n                }\n                node.insertBefore(childNode, reference || null)\n            })\n            break\n        case options._const.removeElement:\n            node.parentNode.removeChild(node)\n            break\n        case options._const.addElement: {\n            const parentRoute = route.slice()\n            const c: number = parentRoute.splice(parentRoute.length - 1, 1)[0]\n            node = getFromRoute(tree, parentRoute)\n            if (!checkElementType(node, options.simplifiedElementCheck, \"Element\")) {\n                return false\n            }\n            node.insertBefore(\n                objToNode(\n                    diff[options._const.element] as nodeType,\n                    node.namespaceURI === \"http://www.w3.org/2000/svg\",\n                    options,\n                ),\n                node.childNodes[c] || null,\n            )\n            break\n        }\n        case options._const.removeTextElement: {\n            if (!node || node.nodeType !== 3) {\n                return false\n            }\n            const parentNode = node.parentNode\n            parentNode.removeChild(node)\n            if (checkElementType(parentNode, options.simplifiedElementCheck, \"HTMLTextAreaElement\")) {\n                parentNode.value = \"\"\n            }\n            break\n        }\n        case options._const.addTextElement: {\n            const parentRoute = route.slice()\n            const c: number = parentRoute.splice(parentRoute.length - 1, 1)[0]\n            newNode = options.document.createTextNode(\n                diff[options._const.value] as string,\n            )\n            node = getFromRoute(tree, parentRoute)\n            if (!node.childNodes) {\n                return false\n            }\n            node.insertBefore(newNode, node.childNodes[c] || null)\n            if (checkElementType(node.parentNode, options.simplifiedElementCheck, \"HTMLTextAreaElement\")) {\n                node.parentNode.value = diff[options._const.value] as string\n            }\n            break\n        }\n        default:\n            console.log(\"unknown action\")\n    }\n\n    // if a new node was created, we might be interested in its\n    // post diff hook\n    options.postDiffApply({\n        diff: info.diff,\n        node: info.node,\n        newNode,\n    })\n\n    return true\n}\n\nexport function applyDOM(\n    tree: Element,\n    diffs: (Diff | diffType)[],\n    options: DiffDOMOptions,\n) {\n    return diffs.every((diff: Diff | diffType) =>\n        applyDiff(tree, diff as diffType, options),\n    )\n}\n","import { DiffDOMOptions, diffType } from \"../types\"\nimport { Diff } from \"../helpers\"\nimport { applyDiff } from \"./apply\"\n\n// ===== Undo a diff =====\n\nfunction swap(obj: object, p1: string | number, p2: string | number) {\n    const tmp = obj[p1]\n    obj[p1] = obj[p2]\n    obj[p2] = tmp\n}\n\nfunction undoDiff(\n    tree: Element,\n    diff: diffType,\n    options: DiffDOMOptions, // {preDiffApply, postDiffApply, textDiff, valueDiffing, _const}\n) {\n    switch (diff[options._const.action]) {\n        case options._const.addAttribute:\n            diff[options._const.action] = options._const.removeAttribute\n            applyDiff(tree, diff, options)\n            break\n        case options._const.modifyAttribute:\n            swap(diff, options._const.oldValue, options._const.newValue)\n            applyDiff(tree, diff, options)\n            break\n        case options._const.removeAttribute:\n            diff[options._const.action] = options._const.addAttribute\n            applyDiff(tree, diff, options)\n            break\n        case options._const.modifyTextElement:\n            swap(diff, options._const.oldValue, options._const.newValue)\n            applyDiff(tree, diff, options)\n            break\n        case options._const.modifyValue:\n            swap(diff, options._const.oldValue, options._const.newValue)\n            applyDiff(tree, diff, options)\n            break\n        case options._const.modifyComment:\n            swap(diff, options._const.oldValue, options._const.newValue)\n            applyDiff(tree, diff, options)\n            break\n        case options._const.modifyChecked:\n            swap(diff, options._const.oldValue, options._const.newValue)\n            applyDiff(tree, diff, options)\n            break\n        case options._const.modifySelected:\n            swap(diff, options._const.oldValue, options._const.newValue)\n            applyDiff(tree, diff, options)\n            break\n        case options._const.replaceElement:\n            swap(diff, options._const.oldValue, options._const.newValue)\n            applyDiff(tree, diff, options)\n            break\n        case options._const.relocateGroup:\n            swap(diff, options._const.from, options._const.to)\n            applyDiff(tree, diff, options)\n            break\n        case options._const.removeElement:\n            diff[options._const.action] = options._const.addElement\n            applyDiff(tree, diff, options)\n            break\n        case options._const.addElement:\n            diff[options._const.action] = options._const.removeElement\n            applyDiff(tree, diff, options)\n            break\n        case options._const.removeTextElement:\n            diff[options._const.action] = options._const.addTextElement\n            applyDiff(tree, diff, options)\n            break\n        case options._const.addTextElement:\n            diff[options._const.action] = options._const.removeTextElement\n            applyDiff(tree, diff, options)\n            break\n        default:\n            console.log(\"unknown action\")\n    }\n}\n\nexport function undoDOM(\n    tree: Element,\n    diffs: (diffType | Diff)[],\n    options: DiffDOMOptions,\n) {\n    diffs = diffs.slice()\n    diffs.reverse()\n    diffs.forEach((diff: diffType | Diff) => {\n        undoDiff(tree, diff as diffType, options)\n    })\n}\n","import {\n    diffNodeType,\n    elementDiffNodeType,\n    elementNodeType,\n    nodeType,\n    subsetType,\n    textDiffNodeType,\n    textNodeType,\n} from \"../types\"\nimport { Diff } from \"../helpers\"\nconst elementDescriptors = (el: diffNodeType) => {\n    const output = []\n    output.push(el.nodeName)\n    if (el.nodeName !== \"#text\" && el.nodeName !== \"#comment\") {\n        el = el as elementDiffNodeType\n        if (el.attributes) {\n            if (el.attributes[\"class\"]) {\n                output.push(\n                    `${el.nodeName}.${el.attributes[\"class\"].replace(\n                        / /g,\n                        \".\",\n                    )}`,\n                )\n            }\n            if (el.attributes.id) {\n                output.push(`${el.nodeName}#${el.attributes.id}`)\n            }\n        }\n    }\n    return output\n}\n\nconst findUniqueDescriptors = (li: diffNodeType[]) => {\n    const uniqueDescriptors = {}\n    const duplicateDescriptors = {}\n\n    li.forEach((node: nodeType) => {\n        elementDescriptors(node).forEach((descriptor) => {\n            const inUnique = descriptor in uniqueDescriptors\n            const inDupes = descriptor in duplicateDescriptors\n            if (!inUnique && !inDupes) {\n                uniqueDescriptors[descriptor] = true\n            } else if (inUnique) {\n                delete uniqueDescriptors[descriptor]\n                duplicateDescriptors[descriptor] = true\n            }\n        })\n    })\n\n    return uniqueDescriptors\n}\n\nexport const uniqueInBoth = (l1: diffNodeType[], l2: diffNodeType[]) => {\n    const l1Unique = findUniqueDescriptors(l1)\n    const l2Unique = findUniqueDescriptors(l2)\n    const inBoth = {}\n\n    Object.keys(l1Unique).forEach((key) => {\n        if (l2Unique[key]) {\n            inBoth[key] = true\n        }\n    })\n\n    return inBoth\n}\n\nexport const removeDone = (tree: elementDiffNodeType) => {\n    delete tree.outerDone\n    delete tree.innerDone\n    delete tree.valueDone\n    if (tree.childNodes) {\n        return tree.childNodes.every(removeDone)\n    } else {\n        return true\n    }\n}\n\nexport const cleanNode = (diffNode: diffNodeType) => {\n    if (Object.prototype.hasOwnProperty.call(diffNode, \"data\")) {\n        const textNode: textNodeType = {\n            nodeName: diffNode.nodeName === \"#text\" ? \"#text\" : \"#comment\",\n            data: (diffNode as textDiffNodeType).data,\n        }\n        return textNode\n    } else {\n        const elementNode: elementNodeType = {\n            nodeName: diffNode.nodeName,\n        }\n        diffNode = diffNode as elementDiffNodeType\n        if (Object.prototype.hasOwnProperty.call(diffNode, \"attributes\")) {\n            elementNode.attributes = { ...diffNode.attributes }\n        }\n        if (Object.prototype.hasOwnProperty.call(diffNode, \"checked\")) {\n            elementNode.checked = diffNode.checked\n        }\n        if (Object.prototype.hasOwnProperty.call(diffNode, \"value\")) {\n            elementNode.value = diffNode.value\n        }\n        if (Object.prototype.hasOwnProperty.call(diffNode, \"selected\")) {\n            elementNode.selected = diffNode.selected\n        }\n        if (Object.prototype.hasOwnProperty.call(diffNode, \"childNodes\")) {\n            elementNode.childNodes = diffNode.childNodes.map((diffChildNode) =>\n                cleanNode(diffChildNode),\n            )\n        }\n        return elementNode\n    }\n}\n\nexport const isEqual = (e1: diffNodeType, e2: diffNodeType) => {\n    if (\n        ![\"nodeName\", \"value\", \"checked\", \"selected\", \"data\"].every(\n            (element) => {\n                if (e1[element] !== e2[element]) {\n                    return false\n                }\n                return true\n            },\n        )\n    ) {\n        return false\n    }\n    if (Object.prototype.hasOwnProperty.call(e1, \"data\")) {\n        // Comment or Text\n        return true\n    }\n    e1 = e1 as elementDiffNodeType\n    e2 = e2 as elementDiffNodeType\n    if (Boolean(e1.attributes) !== Boolean(e2.attributes)) {\n        return false\n    }\n\n    if (Boolean(e1.childNodes) !== Boolean(e2.childNodes)) {\n        return false\n    }\n    if (e1.attributes) {\n        const e1Attributes = Object.keys(e1.attributes)\n        const e2Attributes = Object.keys(e2.attributes)\n\n        if (e1Attributes.length !== e2Attributes.length) {\n            return false\n        }\n        if (\n            !e1Attributes.every((attribute) => {\n                if (\n                    (e1 as elementDiffNodeType).attributes[attribute] !==\n                    (e2 as elementDiffNodeType).attributes[attribute]\n                ) {\n                    return false\n                }\n                return true\n            })\n        ) {\n            return false\n        }\n    }\n    if (e1.childNodes) {\n        if (e1.childNodes.length !== e2.childNodes.length) {\n            return false\n        }\n        if (\n            !e1.childNodes.every((childNode: nodeType, index: number) =>\n                isEqual(childNode, e2.childNodes[index]),\n            )\n        ) {\n            return false\n        }\n    }\n\n    return true\n}\n\nexport const roughlyEqual = (\n    e1: diffNodeType,\n    e2: diffNodeType,\n    uniqueDescriptors: { [key: string]: boolean },\n    sameSiblings: boolean,\n    preventRecursion = false,\n) => {\n    if (!e1 || !e2) {\n        return false\n    }\n\n    if (e1.nodeName !== e2.nodeName) {\n        return false\n    }\n\n    if ([\"#text\", \"#comment\"].includes(e1.nodeName)) {\n        // Note that we initially don't care what the text content of a node is,\n        // the mere fact that it's the same tag and \"has text\" means it's roughly\n        // equal, and then we can find out the true text difference later.\n        return preventRecursion\n            ? true\n            : (e1 as textDiffNodeType).data === (e2 as textDiffNodeType).data\n    }\n\n    e1 = e1 as elementDiffNodeType\n    e2 = e2 as elementDiffNodeType\n\n    if (e1.nodeName in uniqueDescriptors) {\n        return true\n    }\n\n    if (e1.attributes && e2.attributes) {\n        if (e1.attributes.id) {\n            if (e1.attributes.id !== e2.attributes.id) {\n                return false\n            } else {\n                const idDescriptor = `${e1.nodeName}#${e1.attributes.id}`\n                if (idDescriptor in uniqueDescriptors) {\n                    return true\n                }\n            }\n        }\n        if (\n            e1.attributes[\"class\"] &&\n            e1.attributes[\"class\"] === e2.attributes[\"class\"]\n        ) {\n            const classDescriptor = `${e1.nodeName}.${e1.attributes[\n                \"class\"\n            ].replace(/ /g, \".\")}`\n            if (classDescriptor in uniqueDescriptors) {\n                return true\n            }\n        }\n    }\n\n    if (sameSiblings) {\n        return true\n    }\n\n    const nodeList1 = e1.childNodes ? e1.childNodes.slice().reverse() : []\n    const nodeList2 = e2.childNodes ? e2.childNodes.slice().reverse() : []\n\n    if (nodeList1.length !== nodeList2.length) {\n        return false\n    }\n\n    if (preventRecursion) {\n        return nodeList1.every(\n            (element: nodeType, index: number) =>\n                element.nodeName === nodeList2[index].nodeName,\n        )\n    } else {\n        // note: we only allow one level of recursion at any depth. If 'preventRecursion'\n        // was not set, we must explicitly force it to true for child iterations.\n        const childUniqueDescriptors = uniqueInBoth(nodeList1, nodeList2)\n        return nodeList1.every((element: nodeType, index: number) =>\n            roughlyEqual(\n                element,\n                nodeList2[index],\n                childUniqueDescriptors,\n                true,\n                true,\n            ),\n        )\n    }\n}\n\n/**\n * based on https://en.wikibooks.org/wiki/Algorithm_implementation/Strings/Longest_common_substring#JavaScript\n */\nconst findCommonSubsets = (\n    c1: diffNodeType[],\n    c2: diffNodeType[],\n    marked1: boolean[],\n    marked2: boolean[],\n) => {\n    let lcsSize = 0\n    let index: number[] = []\n    const c1Length = c1.length\n    const c2Length = c2.length\n\n    const // set up the matching table\n        matches = [...new Array(c1Length + 1)].map(() => [])\n\n    const uniqueDescriptors = uniqueInBoth(c1, c2)\n\n    let // If all of the elements are the same tag, id and class, then we can\n        // consider them roughly the same even if they have a different number of\n        // children. This will reduce removing and re-adding similar elements.\n        subsetsSame = c1Length === c2Length\n\n    if (subsetsSame) {\n        c1.some((element: nodeType, i: number) => {\n            const c1Desc = elementDescriptors(element)\n            const c2Desc = elementDescriptors(c2[i])\n            if (c1Desc.length !== c2Desc.length) {\n                subsetsSame = false\n                return true\n            }\n            c1Desc.some((description, i) => {\n                if (description !== c2Desc[i]) {\n                    subsetsSame = false\n                    return true\n                }\n            })\n            if (!subsetsSame) {\n                return true\n            }\n        })\n    }\n\n    // fill the matches with distance values\n    for (let c1Index = 0; c1Index < c1Length; c1Index++) {\n        const c1Element = c1[c1Index]\n        for (let c2Index = 0; c2Index < c2Length; c2Index++) {\n            const c2Element = c2[c2Index]\n            if (\n                !marked1[c1Index] &&\n                !marked2[c2Index] &&\n                roughlyEqual(\n                    c1Element,\n                    c2Element,\n                    uniqueDescriptors,\n                    subsetsSame,\n                )\n            ) {\n                matches[c1Index + 1][c2Index + 1] = matches[c1Index][c2Index]\n                    ? matches[c1Index][c2Index] + 1\n                    : 1\n                if (matches[c1Index + 1][c2Index + 1] >= lcsSize) {\n                    lcsSize = matches[c1Index + 1][c2Index + 1]\n                    index = [c1Index + 1, c2Index + 1]\n                }\n            } else {\n                matches[c1Index + 1][c2Index + 1] = 0\n            }\n        }\n    }\n\n    if (lcsSize === 0) {\n        return false\n    }\n\n    return {\n        oldValue: index[0] - lcsSize,\n        newValue: index[1] - lcsSize,\n        length: lcsSize,\n    }\n}\n\nconst makeBooleanArray = (n: number, v: boolean) =>\n    [...new Array(n)].map(() => v)\n\n/**\n * Generate arrays that indicate which node belongs to which subset,\n * or whether it's actually an orphan node, existing in only one\n * of the two trees, rather than somewhere in both.\n *\n * So if t1 = <img><canvas><br>, t2 = <canvas><br><img>.\n * The longest subset is \"<canvas><br>\" (length 2), so it will group 0.\n * The second longest is \"<img>\" (length 1), so it will be group 1.\n * gaps1 will therefore be [1,0,0] and gaps2 [0,0,1].\n *\n * If an element is not part of any group, it will stay being 'true', which\n * is the initial value. For example:\n * t1 = <img><p></p><br><canvas>, t2 = <b></b><br><canvas><img>\n *\n * The \"<p></p>\" and \"<b></b>\" do only show up in one of the two and will\n * therefore be marked by \"true\". The remaining parts are parts of the\n * groups 0 and 1:\n * gaps1 = [1, true, 0, 0], gaps2 = [true, 0, 0, 1]\n *\n */\nexport const getGapInformation = (\n    t1: elementDiffNodeType,\n    t2: elementDiffNodeType,\n    stable: subsetType[],\n) => {\n    const gaps1: (true | number)[] = t1.childNodes\n        ? (makeBooleanArray(t1.childNodes.length, true) as true[])\n        : []\n    const gaps2: (true | number)[] = t2.childNodes\n        ? (makeBooleanArray(t2.childNodes.length, true) as true[])\n        : []\n    let group = 0\n\n    // give elements from the same subset the same group number\n    stable.forEach((subset: subsetType) => {\n        const endOld = subset.oldValue + subset.length\n        const endNew = subset.newValue + subset.length\n\n        for (let j = subset.oldValue; j < endOld; j += 1) {\n            gaps1[j] = group\n        }\n        for (let j = subset.newValue; j < endNew; j += 1) {\n            gaps2[j] = group\n        }\n        group += 1\n    })\n\n    return {\n        gaps1,\n        gaps2,\n    }\n}\n\n/**\n * Find all matching subsets, based on immediate child differences only.\n */\nconst markBoth = (marked1, marked2, subset: subsetType, i: number) => {\n    marked1[subset.oldValue + i] = true\n    marked2[subset.newValue + i] = true\n}\n\nexport const markSubTrees = (\n    oldTree: elementDiffNodeType,\n    newTree: elementDiffNodeType,\n) => {\n    // note: the child lists are views, and so update as we update old/newTree\n    const oldChildren = oldTree.childNodes ? oldTree.childNodes : []\n\n    const newChildren = newTree.childNodes ? newTree.childNodes : []\n    const marked1 = makeBooleanArray(oldChildren.length, false)\n    const marked2 = makeBooleanArray(newChildren.length, false)\n    const subsets = []\n\n    const returnIndex = function () {\n        return arguments[1]\n    }\n\n    let foundAllSubsets = false\n\n    while (!foundAllSubsets) {\n        const subset = findCommonSubsets(\n            oldChildren,\n            newChildren,\n            marked1,\n            marked2,\n        )\n        if (subset) {\n            subsets.push(subset)\n            const subsetArray = [...new Array(subset.length)].map(returnIndex)\n            subsetArray.forEach((item) =>\n                markBoth(marked1, marked2, subset, item),\n            )\n        } else {\n            foundAllSubsets = true\n        }\n    }\n\n    oldTree.subsets = subsets\n    oldTree.subsetsAge = 100\n    return subsets\n}\n\nexport class DiffTracker {\n    list: Diff[]\n    constructor() {\n        this.list = []\n    }\n\n    add(diffs: Diff[]) {\n        this.list.push(...diffs)\n    }\n    forEach(fn: (Diff) => void) {\n        this.list.forEach((li: Diff) => fn(li))\n    }\n}\n","import { DiffDOMOptions, elementNodeType, nodeType, subsetType } from \"../types\"\nimport { Diff } from \"../helpers\"\nimport { cleanNode } from \"./helpers\"\n// ===== Apply a virtual diff =====\n\nfunction getFromVirtualRoute(tree: elementNodeType, route: number[]) {\n    let node = tree\n    let parentNode\n    let nodeIndex\n\n    route = route.slice()\n    while (route.length > 0) {\n        nodeIndex = route.splice(0, 1)[0]\n        parentNode = node\n        node = node.childNodes ? node.childNodes[nodeIndex] : undefined\n    }\n    return {\n        node,\n        parentNode,\n        nodeIndex,\n    }\n}\n\nfunction applyVirtualDiff(\n    tree: elementNodeType,\n    diff: Diff,\n    options: DiffDOMOptions, // {preVirtualDiffApply, postVirtualDiffApply, _const}\n) {\n    let node, parentNode, nodeIndex\n\n    if (\n        ![options._const.addElement, options._const.addTextElement].includes(\n            diff[options._const.action],\n        )\n    ) {\n        // For adding nodes, we calculate the route later on. It's different because it includes the position of the newly added item.\n        const routeInfo = getFromVirtualRoute(tree, diff[options._const.route])\n        node = routeInfo.node\n        parentNode = routeInfo.parentNode\n        nodeIndex = routeInfo.nodeIndex\n    }\n\n    const newSubsets: subsetType[] = []\n\n    // pre-diff hook\n    const info = {\n        diff,\n        node,\n    }\n\n    if (options.preVirtualDiffApply(info)) {\n        return true\n    }\n\n    let newNode\n    let nodeArray\n    let route\n\n    switch (diff[options._const.action]) {\n        case options._const.addAttribute:\n            if (!node.attributes) {\n                node.attributes = {}\n            }\n\n            node.attributes[diff[options._const.name]] =\n                diff[options._const.value]\n\n            if (diff[options._const.name] === \"checked\") {\n                node.checked = true\n            } else if (diff[options._const.name] === \"selected\") {\n                node.selected = true\n            } else if (\n                node.nodeName === \"INPUT\" &&\n                diff[options._const.name] === \"value\"\n            ) {\n                node.value = diff[options._const.value]\n            }\n\n            break\n        case options._const.modifyAttribute:\n            node.attributes[diff[options._const.name]] =\n                diff[options._const.newValue]\n            break\n        case options._const.removeAttribute:\n            delete node.attributes[diff[options._const.name]]\n\n            if (Object.keys(node.attributes).length === 0) {\n                delete node.attributes\n            }\n\n            if (diff[options._const.name] === \"checked\") {\n                node.checked = false\n            } else if (diff[options._const.name] === \"selected\") {\n                delete node.selected\n            } else if (\n                node.nodeName === \"INPUT\" &&\n                diff[options._const.name] === \"value\"\n            ) {\n                delete node.value\n            }\n\n            break\n        case options._const.modifyTextElement:\n            node.data = diff[options._const.newValue]\n            if (parentNode.nodeName === \"TEXTAREA\") {\n                parentNode.value = diff[options._const.newValue]\n            }\n            break\n        case options._const.modifyValue:\n            node.value = diff[options._const.newValue]\n            break\n        case options._const.modifyComment:\n            node.data = diff[options._const.newValue]\n            break\n        case options._const.modifyChecked:\n            node.checked = diff[options._const.newValue]\n            break\n        case options._const.modifySelected:\n            node.selected = diff[options._const.newValue]\n            break\n        case options._const.replaceElement:\n            newNode = cleanNode(diff[options._const.newValue])\n            parentNode.childNodes[nodeIndex] = newNode\n            break\n        case options._const.relocateGroup:\n            nodeArray = node.childNodes\n                .splice(\n                    diff[options._const.from],\n                    diff[options._const.groupLength],\n                )\n                .reverse()\n            nodeArray.forEach((movedNode: nodeType) =>\n                node.childNodes.splice(diff[options._const.to], 0, movedNode),\n            )\n            if (node.subsets) {\n                node.subsets.forEach((map: subsetType) => {\n                    if (\n                        diff[options._const.from] < diff[options._const.to] &&\n                        map.oldValue <= diff[options._const.to] &&\n                        map.oldValue > diff[options._const.from]\n                    ) {\n                        map.oldValue -= diff[options._const.groupLength]\n                        const splitLength =\n                            map.oldValue + map.length - diff[options._const.to]\n                        if (splitLength > 0) {\n                            // new insertion splits map.\n                            newSubsets.push({\n                                oldValue:\n                                    diff[options._const.to] +\n                                    diff[options._const.groupLength],\n                                newValue:\n                                    map.newValue + map.length - splitLength,\n                                length: splitLength,\n                            })\n                            map.length -= splitLength\n                        }\n                    } else if (\n                        diff[options._const.from] > diff[options._const.to] &&\n                        map.oldValue > diff[options._const.to] &&\n                        map.oldValue < diff[options._const.from]\n                    ) {\n                        map.oldValue += diff[options._const.groupLength]\n                        const splitLength =\n                            map.oldValue + map.length - diff[options._const.to]\n                        if (splitLength > 0) {\n                            // new insertion splits map.\n                            newSubsets.push({\n                                oldValue:\n                                    diff[options._const.to] +\n                                    diff[options._const.groupLength],\n                                newValue:\n                                    map.newValue + map.length - splitLength,\n                                length: splitLength,\n                            })\n                            map.length -= splitLength\n                        }\n                    } else if (map.oldValue === diff[options._const.from]) {\n                        map.oldValue = diff[options._const.to]\n                    }\n                })\n            }\n\n            break\n        case options._const.removeElement:\n            parentNode.childNodes.splice(nodeIndex, 1)\n            if (parentNode.subsets) {\n                parentNode.subsets.forEach((map: subsetType) => {\n                    if (map.oldValue > nodeIndex) {\n                        map.oldValue -= 1\n                    } else if (map.oldValue === nodeIndex) {\n                        map.delete = true\n                    } else if (\n                        map.oldValue < nodeIndex &&\n                        map.oldValue + map.length > nodeIndex\n                    ) {\n                        if (map.oldValue + map.length - 1 === nodeIndex) {\n                            map.length--\n                        } else {\n                            newSubsets.push({\n                                newValue:\n                                    map.newValue + nodeIndex - map.oldValue,\n                                oldValue: nodeIndex,\n                                length:\n                                    map.length - nodeIndex + map.oldValue - 1,\n                            })\n                            map.length = nodeIndex - map.oldValue\n                        }\n                    }\n                })\n            }\n            node = parentNode\n            break\n        case options._const.addElement: {\n            route = diff[options._const.route].slice()\n            const c: number = route.splice(route.length - 1, 1)[0]\n            node = getFromVirtualRoute(tree, route)?.node\n            newNode = cleanNode(diff[options._const.element])\n\n            if (!node.childNodes) {\n                node.childNodes = []\n            }\n\n            if (c >= node.childNodes.length) {\n                node.childNodes.push(newNode)\n            } else {\n                node.childNodes.splice(c, 0, newNode)\n            }\n            if (node.subsets) {\n                node.subsets.forEach((map: subsetType) => {\n                    if (map.oldValue >= c) {\n                        map.oldValue += 1\n                    } else if (\n                        map.oldValue < c &&\n                        map.oldValue + map.length > c\n                    ) {\n                        const splitLength = map.oldValue + map.length - c\n                        newSubsets.push({\n                            newValue: map.newValue + map.length - splitLength,\n                            oldValue: c + 1,\n                            length: splitLength,\n                        })\n                        map.length -= splitLength\n                    }\n                })\n            }\n            break\n        }\n        case options._const.removeTextElement:\n            parentNode.childNodes.splice(nodeIndex, 1)\n            if (parentNode.nodeName === \"TEXTAREA\") {\n                delete parentNode.value\n            }\n            if (parentNode.subsets) {\n                parentNode.subsets.forEach((map: subsetType) => {\n                    if (map.oldValue > nodeIndex) {\n                        map.oldValue -= 1\n                    } else if (map.oldValue === nodeIndex) {\n                        map.delete = true\n                    } else if (\n                        map.oldValue < nodeIndex &&\n                        map.oldValue + map.length > nodeIndex\n                    ) {\n                        if (map.oldValue + map.length - 1 === nodeIndex) {\n                            map.length--\n                        } else {\n                            newSubsets.push({\n                                newValue:\n                                    map.newValue + nodeIndex - map.oldValue,\n                                oldValue: nodeIndex,\n                                length:\n                                    map.length - nodeIndex + map.oldValue - 1,\n                            })\n                            map.length = nodeIndex - map.oldValue\n                        }\n                    }\n                })\n            }\n            node = parentNode\n            break\n        case options._const.addTextElement: {\n            route = diff[options._const.route].slice()\n            const c: number = route.splice(route.length - 1, 1)[0]\n            newNode = {\n                nodeName: \"#text\",\n                data: diff[options._const.value],\n            }\n            node = getFromVirtualRoute(tree, route).node\n            if (!node.childNodes) {\n                node.childNodes = []\n            }\n\n            if (c >= node.childNodes.length) {\n                node.childNodes.push(newNode)\n            } else {\n                node.childNodes.splice(c, 0, newNode)\n            }\n            if (node.nodeName === \"TEXTAREA\") {\n                node.value = diff[options._const.newValue]\n            }\n            if (node.subsets) {\n                node.subsets.forEach((map: subsetType) => {\n                    if (map.oldValue >= c) {\n                        map.oldValue += 1\n                    }\n                    if (map.oldValue < c && map.oldValue + map.length > c) {\n                        const splitLength = map.oldValue + map.length - c\n                        newSubsets.push({\n                            newValue: map.newValue + map.length - splitLength,\n                            oldValue: c + 1,\n                            length: splitLength,\n                        })\n                        map.length -= splitLength\n                    }\n                })\n            }\n            break\n        }\n        default:\n            console.log(\"unknown action\")\n    }\n\n    if (node.subsets) {\n        node.subsets = node.subsets.filter(\n            (map: subsetType) => !map.delete && map.oldValue !== map.newValue,\n        )\n        if (newSubsets.length) {\n            node.subsets = node.subsets.concat(newSubsets)\n        }\n    }\n\n    options.postVirtualDiffApply({\n        node: info.node,\n        diff: info.diff,\n        newNode,\n    })\n\n    return\n}\n\nexport function applyVirtual(\n    tree: elementNodeType,\n    diffs: Diff[],\n    options: DiffDOMOptions,\n) {\n    diffs.forEach((diff: Diff) => {\n        applyVirtualDiff(tree, diff, options)\n    })\n    return true\n}\n","import { DiffDOMOptionsPartial, elementNodeType, textNodeType } from \"../types\"\nimport { checkElementType } from \"../helpers\"\n\nexport function nodeToObj(\n    aNode: Element,\n    options: DiffDOMOptionsPartial = { valueDiffing: true, simplifiedElementCheck: true },\n) {\n    const objNode: elementNodeType | textNodeType = {\n        nodeName: aNode.nodeName,\n    }\n    if (checkElementType(aNode, options.simplifiedElementCheck, \"Text\", \"Comment\")) {\n        ;(objNode as unknown as textNodeType).data = (\n            aNode as unknown as Text | Comment\n        ).data\n    } else {\n        if (aNode.attributes && aNode.attributes.length > 0) {\n            objNode.attributes = {}\n            const nodeArray = Array.prototype.slice.call(aNode.attributes)\n            nodeArray.forEach(\n                (attribute) =>\n                    (objNode.attributes[attribute.name] = attribute.value),\n            )\n        }\n        if (aNode.childNodes && aNode.childNodes.length > 0) {\n            objNode.childNodes = []\n            const nodeArray = Array.prototype.slice.call(aNode.childNodes)\n            nodeArray.forEach((childNode) =>\n                objNode.childNodes.push(nodeToObj(childNode, options)),\n            )\n        }\n        if (options.valueDiffing) {\n            if (checkElementType(aNode, options.simplifiedElementCheck, \"HTMLTextAreaElement\")) {\n                objNode.value = (aNode as HTMLTextAreaElement).value\n            }\n            if (\n                checkElementType(aNode, options.simplifiedElementCheck, \"HTMLInputElement\") &&\n                [\"radio\", \"checkbox\"].includes(\n                    (aNode as HTMLInputElement).type.toLowerCase(),\n                ) &&\n                (aNode as HTMLInputElement).checked !== undefined\n            ) {\n                objNode.checked = (aNode as HTMLInputElement).checked\n            } else if (\n                checkElementType(\n                    aNode,\n                    options.simplifiedElementCheck,\n                    \"HTMLButtonElement\",\n                    \"HTMLDataElement\",\n                    \"HTMLInputElement\",\n                    \"HTMLLIElement\",\n                    \"HTMLMeterElement\",\n                    \"HTMLOptionElement\",\n                    \"HTMLProgressElement\",\n                    \"HTMLParamElement\",\n                )\n            ) {\n                objNode.value = (\n                    aNode as\n                        | HTMLButtonElement\n                        | HTMLDataElement\n                        | HTMLInputElement\n                        | HTMLLIElement\n                        | HTMLMeterElement\n                        | HTMLOptionElement\n                        | HTMLProgressElement\n                        | HTMLParamElement\n                ).value\n            }\n            if (checkElementType(aNode, options.simplifiedElementCheck, \"HTMLOptionElement\")) {\n                objNode.selected = (aNode as HTMLOptionElement).selected\n            }\n        }\n    }\n    return objNode\n}\n","import { DiffDOMOptionsPartial, nodeType } from \"../types\"\n\n// from html-parse-stringify (MIT)\n\nconst tagRE =\n    /<\\s*\\/*[a-zA-Z:_][a-zA-Z0-9:_\\-.]*\\s*(?:\"[^\"]*\"['\"]*|'[^']*'['\"]*|[^'\"/>])*\\/*\\s*>|<!--(?:.|\\n|\\r)*?-->/g\n\nconst attrRE = /\\s([^'\"/\\s><]+?)[\\s/>]|([^\\s=]+)=\\s?(\".*?\"|'.*?')/g\n\nfunction unescape(string: string) {\n    return string\n        .replace(/&lt;/g, \"<\")\n        .replace(/&gt;/g, \">\")\n        .replace(/&amp;/g, \"&\")\n}\n\n// create optimized lookup object for\n// void elements as listed here:\n// https://www.w3.org/html/wg/drafts/html/master/syntax.html#void-elements\nconst lookup = {\n    area: true,\n    base: true,\n    br: true,\n    col: true,\n    embed: true,\n    hr: true,\n    img: true,\n    input: true,\n    keygen: true,\n    link: true,\n    menuItem: true,\n    meta: true,\n    param: true,\n    source: true,\n    track: true,\n    wbr: true,\n}\n\nconst parseTag = (tag: string, caseSensitive: boolean) => {\n    const res = {\n        nodeName: \"\",\n        attributes: {},\n    }\n    let voidElement = false\n    let type = \"tag\"\n\n    let tagMatch = tag.match(/<\\/?([^\\s]+?)[/\\s>]/)\n    if (tagMatch) {\n        res.nodeName =\n            caseSensitive || tagMatch[1] === \"svg\"\n                ? tagMatch[1]\n                : tagMatch[1].toUpperCase()\n        if (lookup[tagMatch[1]] || tag.charAt(tag.length - 2) === \"/\") {\n            voidElement = true\n        }\n\n        // handle comment tag\n        if (res.nodeName.startsWith(\"!--\")) {\n            const endIndex = tag.indexOf(\"-->\")\n            return {\n                type: \"comment\",\n                node: {\n                    nodeName: \"#comment\",\n                    data: endIndex !== -1 ? tag.slice(4, endIndex) : \"\",\n                },\n                voidElement,\n            }\n        }\n    }\n\n    let reg = new RegExp(attrRE)\n    let result = null\n    let done = false\n    while (!done) {\n        result = reg.exec(tag)\n\n        if (result === null) {\n            done = true\n        } else if (result[0].trim()) {\n            if (result[1]) {\n                let attr = result[1].trim()\n                let arr = [attr, \"\"]\n\n                if (attr.indexOf(\"=\") > -1) arr = attr.split(\"=\")\n                res.attributes[arr[0]] = arr[1]\n                reg.lastIndex--\n            } else if (result[2])\n                res.attributes[result[2]] = result[3]\n                    .trim()\n                    .substring(1, result[3].length - 1)\n        }\n    }\n\n    return {\n        type,\n        node: res,\n        voidElement,\n    }\n}\n\nexport const stringToObj = (\n    html: string,\n    options: DiffDOMOptionsPartial = {\n        valueDiffing: true,\n        caseSensitive: false,\n    },\n) => {\n    const result: nodeType[] = []\n    let current: { type: string; node: nodeType; voidElement: boolean }\n    let level = -1\n    const arr: { type: string; node: nodeType; voidElement: boolean }[] = []\n    let inComponent = false,\n        insideSvg = false\n\n    // handle text at top level\n    if (html.indexOf(\"<\") !== 0) {\n        const end = html.indexOf(\"<\")\n        result.push({\n            nodeName: \"#text\",\n            data: end === -1 ? html : html.substring(0, end),\n        })\n    }\n\n    html.replace(tagRE, (tag: string, index: number) => {\n        if (inComponent) {\n            if (tag !== `</${current.node.nodeName}>`) {\n                return \"\"\n            } else {\n                inComponent = false\n            }\n        }\n        const isOpen = tag.charAt(1) !== \"/\"\n        const isComment = tag.startsWith(\"<!--\")\n        const start = index + tag.length\n        const nextChar = html.charAt(start)\n\n        if (isComment) {\n            const comment = parseTag(tag, options.caseSensitive).node\n\n            // if we're at root, push new base node\n            if (level < 0) {\n                result.push(comment)\n                return \"\"\n            }\n            const parent = arr[level]\n            if (parent && comment.nodeName) {\n                if (!parent.node.childNodes) {\n                    parent.node.childNodes = []\n                }\n                parent.node.childNodes.push(comment)\n            }\n            return \"\"\n        }\n\n        if (isOpen) {\n            current = parseTag(tag, options.caseSensitive || insideSvg)\n            if (current.node.nodeName === \"svg\") {\n                insideSvg = true\n            }\n            level++\n            if (\n                !current.voidElement &&\n                !inComponent &&\n                nextChar &&\n                nextChar !== \"<\"\n            ) {\n                if (!current.node.childNodes) {\n                    current.node.childNodes = []\n                }\n                const data = unescape(\n                    html.slice(start, html.indexOf(\"<\", start)),\n                )\n                current.node.childNodes.push({\n                    nodeName: \"#text\",\n                    data,\n                })\n                if (\n                    options.valueDiffing &&\n                    current.node.nodeName === \"TEXTAREA\"\n                ) {\n                    current.node.value = data\n                }\n            }\n            // if we're at root, push new base node\n            if (level === 0 && current.node.nodeName) {\n                result.push(current.node)\n            }\n\n            const parent = arr[level - 1]\n            if (parent && current.node.nodeName) {\n                if (!parent.node.childNodes) {\n                    parent.node.childNodes = []\n                }\n                parent.node.childNodes.push(current.node)\n            }\n            arr[level] = current\n        }\n        if (!isOpen || current.voidElement) {\n            if (\n                level > -1 &&\n                (current.voidElement ||\n                    (options.caseSensitive &&\n                        current.node.nodeName === tag.slice(2, -1)) ||\n                    (!options.caseSensitive &&\n                        current.node.nodeName.toUpperCase() ===\n                            tag.slice(2, -1).toUpperCase()))\n            ) {\n                level--\n                // move current up a level to match the end tag\n                if (level > -1) {\n                    if (current.node.nodeName === \"svg\") {\n                        insideSvg = false\n                    }\n                    current = arr[level]\n                }\n            }\n            if (!inComponent && nextChar !== \"<\" && nextChar) {\n                // trailing text node\n                // if we're at the root, push a base text node. otherwise add as\n                // a child to the current node.\n                const childNodes =\n                    level === -1 ? result : arr[level].node.childNodes || []\n\n                // calculate correct end of the data slice in case there's\n                // no tag after the text node.\n                const end = html.indexOf(\"<\", start)\n                let data = unescape(\n                    html.slice(start, end === -1 ? undefined : end),\n                )\n                childNodes.push({\n                    nodeName: \"#text\",\n                    data,\n                })\n            }\n        }\n        return \"\"\n    })\n    return result[0]\n}\n","import {\n    DiffDOMOptions,\n    diffNodeType,\n    elementDiffNodeType,\n    elementNodeType,\n    subsetType,\n    textDiffNodeType,\n} from \"../types\"\nimport {\n    DiffTracker,\n    cleanNode,\n    getGapInformation,\n    isEqual,\n    markSubTrees,\n    removeDone,\n    roughlyEqual,\n} from \"./helpers\"\nimport { Diff, checkElementType } from \"../helpers\"\nimport { applyVirtual } from \"./apply\"\nimport { nodeToObj } from \"./fromDOM\"\nimport { stringToObj } from \"./fromString\"\n\n// ===== Create a diff =====\n\nexport class DiffFinder {\n    debug: boolean\n    diffcount: number\n    foundAll: boolean\n    options: DiffDOMOptions\n    t1: elementDiffNodeType\n    t1Orig: elementNodeType\n    t2: elementDiffNodeType\n    t2Orig: elementNodeType\n    tracker: DiffTracker\n    constructor(\n        t1Node: string | elementNodeType | Element,\n        t2Node: string | elementNodeType | Element,\n        options: DiffDOMOptions,\n    ) {\n        this.options = options\n        this.t1 = (\n            typeof Element !== \"undefined\" &&\n            checkElementType(t1Node, this.options.simplifiedElementCheck, \"Element\")\n                ? nodeToObj(t1Node as Element, this.options)\n                : typeof t1Node === \"string\"\n                  ? stringToObj(t1Node, this.options)\n                  : JSON.parse(JSON.stringify(t1Node))\n        ) as elementDiffNodeType\n        this.t2 = (\n            typeof Element !== \"undefined\" &&\n            checkElementType(t2Node, this.options.simplifiedElementCheck, \"Element\")\n                ? nodeToObj(t2Node as Element, this.options)\n                : typeof t2Node === \"string\"\n                  ? stringToObj(t2Node, this.options)\n                  : JSON.parse(JSON.stringify(t2Node))\n        ) as elementDiffNodeType\n        this.diffcount = 0\n        this.foundAll = false\n        if (this.debug) {\n            this.t1Orig =\n                typeof Element !== \"undefined\" &&\n                checkElementType(t1Node, this.options.simplifiedElementCheck, \"Element\")\n                    ? nodeToObj(t1Node as Element, this.options)\n                    : typeof t1Node === \"string\"\n                      ? stringToObj(t1Node, this.options)\n                      : JSON.parse(JSON.stringify(t1Node))\n            this.t2Orig =\n                typeof Element !== \"undefined\" &&\n                checkElementType(t2Node, this.options.simplifiedElementCheck, \"Element\")\n                    ? nodeToObj(t2Node as Element, this.options)\n                    : typeof t2Node === \"string\"\n                      ? stringToObj(t2Node, this.options)\n                      : JSON.parse(JSON.stringify(t2Node))\n        }\n\n        this.tracker = new DiffTracker()\n    }\n\n    init() {\n        return this.findDiffs(this.t1, this.t2)\n    }\n\n    findDiffs(t1: elementDiffNodeType, t2: elementDiffNodeType) {\n        let diffs\n        do {\n            if (this.options.debug) {\n                this.diffcount += 1\n                if (this.diffcount > this.options.diffcap) {\n                    throw new Error(\n                        `surpassed diffcap:${JSON.stringify(\n                            this.t1Orig,\n                        )} -> ${JSON.stringify(this.t2Orig)}`,\n                    )\n                }\n            }\n            diffs = this.findNextDiff(t1, t2, [])\n\n            if (diffs.length === 0) {\n                // Last check if the elements really are the same now.\n                // If not, remove all info about being done and start over.\n                // Sometimes a node can be marked as done, but the creation of subsequent diffs means that it has to be changed again.\n                if (!isEqual(t1, t2)) {\n                    if (this.foundAll) {\n                        console.error(\"Could not find remaining diffs!\")\n                    } else {\n                        this.foundAll = true\n                        removeDone(t1)\n                        diffs = this.findNextDiff(t1, t2, [])\n                    }\n                }\n            }\n            if (diffs.length > 0) {\n                this.foundAll = false\n                this.tracker.add(diffs)\n                applyVirtual(t1, diffs, this.options)\n            }\n        } while (diffs.length > 0)\n\n        return this.tracker.list\n    }\n\n    findNextDiff(t1: diffNodeType, t2: diffNodeType, route: number[]) {\n        let diffs\n        let fdiffs\n\n        if (this.options.maxDepth && route.length > this.options.maxDepth) {\n            return []\n        }\n        // outer differences?\n        if (!t1.outerDone) {\n            diffs = this.findOuterDiff(t1, t2, route)\n            if (this.options.filterOuterDiff) {\n                fdiffs = this.options.filterOuterDiff(t1, t2, diffs)\n                if (fdiffs) diffs = fdiffs\n            }\n            if (diffs.length > 0) {\n                t1.outerDone = true\n                return diffs\n            } else {\n                t1.outerDone = true\n            }\n        }\n        if (Object.prototype.hasOwnProperty.call(t1, \"data\")) {\n            // Comment or Text\n            return []\n        }\n        t1 = t1 as elementDiffNodeType\n        t2 = t2 as elementDiffNodeType\n\n        // inner differences?\n        if (!t1.innerDone) {\n            diffs = this.findInnerDiff(t1, t2, route)\n            if (diffs.length > 0) {\n                return diffs\n            } else {\n                t1.innerDone = true\n            }\n        }\n\n        if (this.options.valueDiffing && !t1.valueDone) {\n            // value differences?\n            diffs = this.findValueDiff(t1, t2, route)\n\n            if (diffs.length > 0) {\n                t1.valueDone = true\n                return diffs\n            } else {\n                t1.valueDone = true\n            }\n        }\n\n        // no differences\n        return []\n    }\n\n    findOuterDiff(t1: diffNodeType, t2: diffNodeType, route: number[]) {\n        const diffs = []\n        let attr\n        let attr1\n        let attr2\n        let attrLength\n        let pos\n        let i\n        if (t1.nodeName !== t2.nodeName) {\n            if (!route.length) {\n                throw new Error(\"Top level nodes have to be of the same kind.\")\n            }\n            return [\n                new Diff()\n                    .setValue(\n                        this.options._const.action,\n                        this.options._const.replaceElement,\n                    )\n                    .setValue(this.options._const.oldValue, cleanNode(t1))\n                    .setValue(this.options._const.newValue, cleanNode(t2))\n                    .setValue(this.options._const.route, route),\n            ]\n        }\n        if (\n            route.length &&\n            this.options.diffcap <\n                Math.abs(\n                    (t1.childNodes || []).length - (t2.childNodes || []).length,\n                )\n        ) {\n            return [\n                new Diff()\n                    .setValue(\n                        this.options._const.action,\n                        this.options._const.replaceElement,\n                    )\n                    .setValue(this.options._const.oldValue, cleanNode(t1))\n                    .setValue(this.options._const.newValue, cleanNode(t2))\n                    .setValue(this.options._const.route, route),\n            ]\n        }\n\n        if (\n            Object.prototype.hasOwnProperty.call(t1, \"data\") &&\n            (t1 as textDiffNodeType).data !== (t2 as textDiffNodeType).data\n        ) {\n            // Comment or text node.\n            if (t1.nodeName === \"#text\") {\n                return [\n                    new Diff()\n                        .setValue(\n                            this.options._const.action,\n                            this.options._const.modifyTextElement,\n                        )\n                        .setValue(this.options._const.route, route)\n                        .setValue(\n                            this.options._const.oldValue,\n                            (t1 as textDiffNodeType).data,\n                        )\n                        .setValue(\n                            this.options._const.newValue,\n                            (t2 as textDiffNodeType).data,\n                        ),\n                ]\n            } else {\n                return [\n                    new Diff()\n                        .setValue(\n                            this.options._const.action,\n                            this.options._const.modifyComment,\n                        )\n                        .setValue(this.options._const.route, route)\n                        .setValue(\n                            this.options._const.oldValue,\n                            (t1 as textDiffNodeType).data,\n                        )\n                        .setValue(\n                            this.options._const.newValue,\n                            (t2 as textDiffNodeType).data,\n                        ),\n                ]\n            }\n        }\n\n        t1 = t1 as elementDiffNodeType\n        t2 = t2 as elementDiffNodeType\n\n        attr1 = t1.attributes ? Object.keys(t1.attributes).sort() : []\n        attr2 = t2.attributes ? Object.keys(t2.attributes).sort() : []\n\n        attrLength = attr1.length\n        for (i = 0; i < attrLength; i++) {\n            attr = attr1[i]\n            pos = attr2.indexOf(attr)\n            if (pos === -1) {\n                diffs.push(\n                    new Diff()\n                        .setValue(\n                            this.options._const.action,\n                            this.options._const.removeAttribute,\n                        )\n                        .setValue(this.options._const.route, route)\n                        .setValue(this.options._const.name, attr)\n                        .setValue(\n                            this.options._const.value,\n                            t1.attributes[attr],\n                        ),\n                )\n            } else {\n                attr2.splice(pos, 1)\n                if (t1.attributes[attr] !== t2.attributes[attr]) {\n                    diffs.push(\n                        new Diff()\n                            .setValue(\n                                this.options._const.action,\n                                this.options._const.modifyAttribute,\n                            )\n                            .setValue(this.options._const.route, route)\n                            .setValue(this.options._const.name, attr)\n                            .setValue(\n                                this.options._const.oldValue,\n                                t1.attributes[attr],\n                            )\n                            .setValue(\n                                this.options._const.newValue,\n                                t2.attributes[attr],\n                            ),\n                    )\n                }\n            }\n        }\n\n        attrLength = attr2.length\n        for (i = 0; i < attrLength; i++) {\n            attr = attr2[i]\n            diffs.push(\n                new Diff()\n                    .setValue(\n                        this.options._const.action,\n                        this.options._const.addAttribute,\n                    )\n                    .setValue(this.options._const.route, route)\n                    .setValue(this.options._const.name, attr)\n                    .setValue(this.options._const.value, t2.attributes[attr]),\n            )\n        }\n\n        return diffs\n    }\n\n    findInnerDiff(\n        t1: elementDiffNodeType,\n        t2: elementDiffNodeType,\n        route: number[],\n    ) {\n        const t1ChildNodes = t1.childNodes ? t1.childNodes.slice() : []\n        const t2ChildNodes = t2.childNodes ? t2.childNodes.slice() : []\n        const last = Math.max(t1ChildNodes.length, t2ChildNodes.length)\n        let childNodesLengthDifference = Math.abs(\n            t1ChildNodes.length - t2ChildNodes.length,\n        )\n        let diffs: Diff[] = []\n        let index = 0\n        if (!this.options.maxChildCount || last < this.options.maxChildCount) {\n            const cachedSubtrees = Boolean(t1.subsets && t1.subsetsAge--)\n            const subtrees = cachedSubtrees\n                ? t1.subsets\n                : t1.childNodes && t2.childNodes\n                  ? markSubTrees(t1, t2)\n                  : []\n            if (subtrees.length > 0) {\n                /* One or more groups have been identified among the childnodes of t1\n                 * and t2.\n                 */\n                diffs = this.attemptGroupRelocation(\n                    t1,\n                    t2,\n                    subtrees,\n                    route,\n                    cachedSubtrees,\n                )\n                if (diffs.length > 0) {\n                    return diffs\n                }\n            }\n        }\n\n        /* 0 or 1 groups of similar child nodes have been found\n         * for t1 and t2. 1 If there is 1, it could be a sign that the\n         * contents are the same. When the number of groups is below 2,\n         * t1 and t2 are made to have the same length and each of the\n         * pairs of child nodes are diffed.\n         */\n\n        for (let i = 0; i < last; i += 1) {\n            const e1 = t1ChildNodes[i]\n            const e2 = t2ChildNodes[i]\n\n            if (childNodesLengthDifference) {\n                /* t1 and t2 have different amounts of childNodes. Add\n                 * and remove as necessary to obtain the same length */\n                if (e1 && !e2) {\n                    if (e1.nodeName === \"#text\") {\n                        diffs.push(\n                            new Diff()\n                                .setValue(\n                                    this.options._const.action,\n                                    this.options._const.removeTextElement,\n                                )\n                                .setValue(\n                                    this.options._const.route,\n                                    route.concat(index),\n                                )\n                                .setValue(\n                                    this.options._const.value,\n                                    (e1 as textDiffNodeType).data,\n                                ),\n                        )\n                        index -= 1\n                    } else {\n                        diffs.push(\n                            new Diff()\n                                .setValue(\n                                    this.options._const.action,\n                                    this.options._const.removeElement,\n                                )\n                                .setValue(\n                                    this.options._const.route,\n                                    route.concat(index),\n                                )\n                                .setValue(\n                                    this.options._const.element,\n                                    cleanNode(e1),\n                                ),\n                        )\n                        index -= 1\n                    }\n                } else if (e2 && !e1) {\n                    if (e2.nodeName === \"#text\") {\n                        diffs.push(\n                            new Diff()\n                                .setValue(\n                                    this.options._const.action,\n                                    this.options._const.addTextElement,\n                                )\n                                .setValue(\n                                    this.options._const.route,\n                                    route.concat(index),\n                                )\n                                .setValue(\n                                    this.options._const.value,\n                                    (e2 as textDiffNodeType).data,\n                                ),\n                        )\n                    } else {\n                        diffs.push(\n                            new Diff()\n                                .setValue(\n                                    this.options._const.action,\n                                    this.options._const.addElement,\n                                )\n                                .setValue(\n                                    this.options._const.route,\n                                    route.concat(index),\n                                )\n                                .setValue(\n                                    this.options._const.element,\n                                    cleanNode(e2),\n                                ),\n                        )\n                    }\n                }\n            }\n            /* We are now guaranteed that childNodes e1 and e2 exist,\n             * and that they can be diffed.\n             */\n            /* Diffs in child nodes should not affect the parent node,\n             * so we let these diffs be submitted together with other\n             * diffs.\n             */\n\n            if (e1 && e2) {\n                if (\n                    !this.options.maxChildCount ||\n                    last < this.options.maxChildCount\n                ) {\n                    diffs = diffs.concat(\n                        this.findNextDiff(e1, e2, route.concat(index)),\n                    )\n                } else if (!isEqual(e1, e2)) {\n                    if (t1ChildNodes.length > t2ChildNodes.length) {\n                        if (e1.nodeName === \"#text\") {\n                            diffs.push(\n                                new Diff()\n                                    .setValue(\n                                        this.options._const.action,\n                                        this.options._const.removeTextElement,\n                                    )\n                                    .setValue(\n                                        this.options._const.route,\n                                        route.concat(index),\n                                    )\n                                    .setValue(\n                                        this.options._const.value,\n                                        (e1 as textDiffNodeType).data,\n                                    ),\n                            )\n                        } else {\n                            diffs.push(\n                                new Diff()\n                                    .setValue(\n                                        this.options._const.action,\n                                        this.options._const.removeElement,\n                                    )\n                                    .setValue(\n                                        this.options._const.element,\n                                        cleanNode(e1),\n                                    )\n                                    .setValue(\n                                        this.options._const.route,\n                                        route.concat(index),\n                                    ),\n                            )\n                        }\n                        t1ChildNodes.splice(i, 1)\n                        i -= 1\n                        index -= 1\n\n                        childNodesLengthDifference -= 1\n                    } else if (t1ChildNodes.length < t2ChildNodes.length) {\n                        diffs = diffs.concat([\n                            new Diff()\n                                .setValue(\n                                    this.options._const.action,\n                                    this.options._const.addElement,\n                                )\n                                .setValue(\n                                    this.options._const.element,\n                                    cleanNode(e2),\n                                )\n                                .setValue(\n                                    this.options._const.route,\n                                    route.concat(index),\n                                ),\n                        ])\n                        t1ChildNodes.splice(i, 0, cleanNode(e2))\n                        childNodesLengthDifference -= 1\n                    } else {\n                        diffs = diffs.concat([\n                            new Diff()\n                                .setValue(\n                                    this.options._const.action,\n                                    this.options._const.replaceElement,\n                                )\n                                .setValue(\n                                    this.options._const.oldValue,\n                                    cleanNode(e1),\n                                )\n                                .setValue(\n                                    this.options._const.newValue,\n                                    cleanNode(e2),\n                                )\n                                .setValue(\n                                    this.options._const.route,\n                                    route.concat(index),\n                                ),\n                        ])\n                    }\n                }\n            }\n            index += 1\n        }\n        t1.innerDone = true\n        return diffs\n    }\n\n    attemptGroupRelocation(\n        t1: elementDiffNodeType,\n        t2: elementDiffNodeType,\n        subtrees: subsetType[],\n        route: number[],\n        cachedSubtrees: boolean,\n    ) {\n        /* Either t1.childNodes and t2.childNodes have the same length, or\n         * there are at least two groups of similar elements can be found.\n         * attempts are made at equalizing t1 with t2. First all initial\n         * elements with no group affiliation (gaps=true) are removed (if\n         * only in t1) or added (if only in t2). Then the creation of a group\n         * relocation diff is attempted.\n         */\n        const gapInformation = getGapInformation(t1, t2, subtrees)\n        const gaps1 = gapInformation.gaps1\n        const gaps2 = gapInformation.gaps2\n        const t1ChildNodes = t1.childNodes.slice()\n        const t2ChildNodes = t2.childNodes.slice()\n        let shortest = Math.min(gaps1.length, gaps2.length)\n        let destinationDifferent\n        let toGroup\n        let group\n        let node\n        let similarNode\n        const diffs = []\n        for (\n            let index2 = 0, index1 = 0;\n            index2 < shortest;\n            index1 += 1, index2 += 1\n        ) {\n            if (\n                cachedSubtrees &&\n                (gaps1[index2] === true || gaps2[index2] === true)\n            ) {\n                // pass\n            } else if (gaps1[index1] === true) {\n                node = t1ChildNodes[index1]\n                if (node.nodeName === \"#text\") {\n                    if (t2ChildNodes[index2].nodeName === \"#text\") {\n                        if (\n                            (node as textDiffNodeType).data !==\n                            (t2ChildNodes[index2] as textDiffNodeType).data\n                        ) {\n                            // Check whether a text node with the same value follows later on.\n                            let testI = index1\n                            while (\n                                t1ChildNodes.length > testI + 1 &&\n                                t1ChildNodes[testI + 1].nodeName === \"#text\"\n                            ) {\n                                testI += 1\n                                if (\n                                    (t2ChildNodes[index2] as textDiffNodeType)\n                                        .data ===\n                                    (t1ChildNodes[testI] as textDiffNodeType)\n                                        .data\n                                ) {\n                                    similarNode = true\n                                    break\n                                }\n                            }\n                            if (!similarNode) {\n                                diffs.push(\n                                    new Diff()\n                                        .setValue(\n                                            this.options._const.action,\n                                            this.options._const\n                                                .modifyTextElement,\n                                        )\n                                        .setValue(\n                                            this.options._const.route,\n                                            route.concat(index1),\n                                        )\n                                        .setValue(\n                                            this.options._const.oldValue,\n                                            node.data,\n                                        )\n                                        .setValue(\n                                            this.options._const.newValue,\n                                            (\n                                                t2ChildNodes[\n                                                    index2\n                                                ] as textDiffNodeType\n                                            ).data,\n                                        ),\n                                    // t1ChildNodes at position index1 is not up-to-date, but that does not matter as\n                                    // index1 will increase +1\n                                )\n                            }\n                        }\n                    } else {\n                        diffs.push(\n                            new Diff()\n                                .setValue(\n                                    this.options._const.action,\n                                    this.options._const.removeTextElement,\n                                )\n                                .setValue(\n                                    this.options._const.route,\n                                    route.concat(index1),\n                                )\n                                .setValue(this.options._const.value, node.data),\n                        )\n                        gaps1.splice(index1, 1)\n                        t1ChildNodes.splice(index1, 1)\n                        shortest = Math.min(gaps1.length, gaps2.length)\n                        index1 -= 1\n                        index2 -= 1\n                    }\n                } else if (gaps2[index2] === true) {\n                    // both gaps1[index1] and gaps2[index2]  are true.\n                    // We replace one element with another.\n                    diffs.push(\n                        new Diff()\n                            .setValue(\n                                this.options._const.action,\n                                this.options._const.replaceElement,\n                            )\n                            .setValue(\n                                this.options._const.oldValue,\n                                cleanNode(node),\n                            )\n                            .setValue(\n                                this.options._const.newValue,\n                                cleanNode(t2ChildNodes[index2]),\n                            )\n                            .setValue(\n                                this.options._const.route,\n                                route.concat(index1),\n                            ),\n                    )\n                    // t1ChildNodes at position index1 is not up-to-date, but that does not matter as\n                    // index1 will increase +1\n                } else {\n                    diffs.push(\n                        new Diff()\n                            .setValue(\n                                this.options._const.action,\n                                this.options._const.removeElement,\n                            )\n                            .setValue(\n                                this.options._const.route,\n                                route.concat(index1),\n                            )\n                            .setValue(\n                                this.options._const.element,\n                                cleanNode(node),\n                            ),\n                    )\n                    gaps1.splice(index1, 1)\n                    t1ChildNodes.splice(index1, 1)\n                    shortest = Math.min(gaps1.length, gaps2.length)\n                    index1 -= 1\n                    index2 -= 1\n                }\n            } else if (gaps2[index2] === true) {\n                node = t2ChildNodes[index2]\n                if (node.nodeName === \"#text\") {\n                    diffs.push(\n                        new Diff()\n                            .setValue(\n                                this.options._const.action,\n                                this.options._const.addTextElement,\n                            )\n                            .setValue(\n                                this.options._const.route,\n                                route.concat(index1),\n                            )\n                            .setValue(this.options._const.value, node.data),\n                    )\n                    gaps1.splice(index1, 0, true)\n                    t1ChildNodes.splice(index1, 0, {\n                        nodeName: \"#text\",\n                        data: node.data,\n                    })\n                    shortest = Math.min(gaps1.length, gaps2.length)\n                    //index1 += 1\n                } else {\n                    diffs.push(\n                        new Diff()\n                            .setValue(\n                                this.options._const.action,\n                                this.options._const.addElement,\n                            )\n                            .setValue(\n                                this.options._const.route,\n                                route.concat(index1),\n                            )\n                            .setValue(\n                                this.options._const.element,\n                                cleanNode(node),\n                            ),\n                    )\n                    gaps1.splice(index1, 0, true)\n                    t1ChildNodes.splice(index1, 0, cleanNode(node))\n                    shortest = Math.min(gaps1.length, gaps2.length)\n                    //index1 += 1\n                }\n            } else if (gaps1[index1] !== gaps2[index2]) {\n                if (diffs.length > 0) {\n                    return diffs\n                }\n                // group relocation\n                group = subtrees[gaps1[index1] as number]\n                toGroup = Math.min(\n                    group.newValue,\n                    t1ChildNodes.length - group.length,\n                )\n                if (toGroup !== group.oldValue && toGroup > -1) {\n                    // Check whether destination nodes are different than originating ones.\n                    destinationDifferent = false\n                    for (let j = 0; j < group.length; j += 1) {\n                        if (\n                            !roughlyEqual(\n                                t1ChildNodes[toGroup + j],\n                                t1ChildNodes[group.oldValue + j],\n                                {},\n                                false,\n                                true,\n                            )\n                        ) {\n                            destinationDifferent = true\n                        }\n                    }\n                    if (destinationDifferent) {\n                        return [\n                            new Diff()\n                                .setValue(\n                                    this.options._const.action,\n                                    this.options._const.relocateGroup,\n                                )\n                                .setValue(\n                                    this.options._const.groupLength,\n                                    group.length,\n                                )\n                                .setValue(\n                                    this.options._const.from,\n                                    group.oldValue,\n                                )\n                                .setValue(this.options._const.to, toGroup)\n                                .setValue(this.options._const.route, route),\n                        ]\n                    }\n                }\n            }\n        }\n        return diffs\n    }\n\n    findValueDiff(\n        t1: elementDiffNodeType,\n        t2: elementDiffNodeType,\n        route: number[],\n    ) {\n        // Differences of value. Only useful if the value/selection/checked value\n        // differs from what is represented in the DOM. For example in the case\n        // of filled out forms, etc.\n        const diffs = []\n\n        if (t1.selected !== t2.selected) {\n            diffs.push(\n                new Diff()\n                    .setValue(\n                        this.options._const.action,\n                        this.options._const.modifySelected,\n                    )\n                    .setValue(this.options._const.oldValue, t1.selected)\n                    .setValue(this.options._const.newValue, t2.selected)\n                    .setValue(this.options._const.route, route),\n            )\n        }\n\n        if (\n            (t1.value || t2.value) &&\n            t1.value !== t2.value &&\n            t1.nodeName !== \"OPTION\"\n        ) {\n            diffs.push(\n                new Diff()\n                    .setValue(\n                        this.options._const.action,\n                        this.options._const.modifyValue,\n                    )\n                    .setValue(this.options._const.oldValue, t1.value || \"\")\n                    .setValue(this.options._const.newValue, t2.value || \"\")\n                    .setValue(this.options._const.route, route),\n            )\n        }\n        if (t1.checked !== t2.checked) {\n            diffs.push(\n                new Diff()\n                    .setValue(\n                        this.options._const.action,\n                        this.options._const.modifyChecked,\n                    )\n                    .setValue(this.options._const.oldValue, t1.checked)\n                    .setValue(this.options._const.newValue, t2.checked)\n                    .setValue(this.options._const.route, route),\n            )\n        }\n\n        return diffs\n    }\n}\n","import {\n    ConstNames,\n    ConstNamesPartial,\n    DiffDOMOptions,\n    DiffDOMOptionsPartial,\n    diffType,\n    elementNodeType,\n    textNodeType,\n} from \"./types\"\nimport { applyDOM, undoDOM } from \"./dom/index\"\nimport { Diff } from \"./helpers\"\nimport { DiffFinder } from \"./virtual/index\"\nexport { nodeToObj, stringToObj } from \"./virtual/index\"\n\nconst DEFAULT_OPTIONS = {\n    debug: false,\n    diffcap: 10, // Limit for how many diffs are accepting when debugging. Inactive when debug is false.\n    maxDepth: false, // False or a numeral. If set to a numeral, limits the level of depth that the the diff mechanism looks for differences. If false, goes through the entire tree.\n    maxChildCount: 50, // False or a numeral. If set to a numeral, only does a simplified form of diffing of contents so that the number of diffs cannot be higher than the number of child nodes.\n    valueDiffing: true, // Whether to take into consideration the values of forms that differ from auto assigned values (when a user fills out a form).\n    simplifiedElementCheck: true, // Whether to use simplified element type checking for primitive virtual DOMs without ownerDocument\n    // syntax: textDiff: function (node, currentValue, expectedValue, newValue)\n    textDiff(\n        node: textNodeType,\n        currentValue: string,\n        expectedValue: string,\n        newValue: string,\n    ) {\n        node.data = newValue\n        return\n    },\n    // empty functions were benchmarked as running faster than both\n    // `f && f()` and `if (f) { f(); }`\n    preVirtualDiffApply() {}, // eslint-disable-line @typescript-eslint/no-empty-function\n    postVirtualDiffApply() {}, // eslint-disable-line @typescript-eslint/no-empty-function\n    preDiffApply() {}, // eslint-disable-line @typescript-eslint/no-empty-function\n    postDiffApply() {}, // eslint-disable-line @typescript-eslint/no-empty-function\n    filterOuterDiff: null,\n    compress: false, // Whether to work with compressed diffs\n    _const: false, // object with strings for every change types to be used in diffs.\n    document:\n        typeof window !== \"undefined\" && window.document\n            ? window.document\n            : false,\n    components: [], // list of components used for converting from string\n}\n\nexport class DiffDOM {\n    options: DiffDOMOptions\n    constructor(options: DiffDOMOptionsPartial = {}) {\n        // IE11 doesn't have Object.assign and buble doesn't translate object spreaders\n        // by default, so this is the safest way of doing it currently.\n        Object.entries(DEFAULT_OPTIONS).forEach(([key, value]) => {\n            if (!Object.prototype.hasOwnProperty.call(options, key)) {\n                options[key] = value\n            }\n        })\n\n        if (!options._const) {\n            const varNames = [\n                \"addAttribute\",\n                \"modifyAttribute\",\n                \"removeAttribute\",\n                \"modifyTextElement\",\n                \"relocateGroup\",\n                \"removeElement\",\n                \"addElement\",\n                \"removeTextElement\",\n                \"addTextElement\",\n                \"replaceElement\",\n                \"modifyValue\",\n                \"modifyChecked\",\n                \"modifySelected\",\n                \"modifyComment\",\n                \"action\",\n                \"route\",\n                \"oldValue\",\n                \"newValue\",\n                \"element\",\n                \"group\",\n                \"groupLength\",\n                \"from\",\n                \"to\",\n                \"name\",\n                \"value\",\n                \"data\",\n                \"attributes\",\n                \"nodeName\",\n                \"childNodes\",\n                \"checked\",\n                \"selected\",\n            ]\n            const constNames: ConstNamesPartial = {}\n            if (options.compress) {\n                varNames.forEach(\n                    (varName, index) => (constNames[varName] = index),\n                )\n            } else {\n                varNames.forEach((varName) => (constNames[varName] = varName))\n            }\n            options._const = constNames as ConstNames\n        }\n\n        this.options = options as DiffDOMOptions\n    }\n\n    apply(tree: Element, diffs: (Diff | diffType)[]) {\n        return applyDOM(tree, diffs, this.options)\n    }\n\n    undo(tree: Element, diffs: (Diff | diffType)[]) {\n        return undoDOM(tree, diffs, this.options)\n    }\n\n    diff(\n        t1Node: string | elementNodeType | Element,\n        t2Node: string | elementNodeType | Element,\n    ) {\n        const finder = new DiffFinder(t1Node, t2Node, this.options)\n        return finder.init()\n    }\n}\n","import { checkElementType } from \"./diffDOM/helpers\"\n\n/**\n * Use TraceLogger to figure out function calls inside\n * JS objects by wrapping an object with a TraceLogger\n * instance.\n *\n * Pretty-prints the call trace (using unicode box code)\n * when tracelogger.toString() is called.\n */\n\n/**\n * Wrap an object by calling new TraceLogger(obj)\n *\n * If you're familiar with Python decorators, this\n * does roughly the same thing, adding pre/post\n * call hook logging calls so that you can see\n * what's going on.\n */\nexport class TraceLogger {\n    messages: string[]\n    pad: string\n    padding: string\n    tick: number\n    constructor(obj = {}) {\n        this.pad = \"   \"\n        this.padding = \"\"\n        this.tick = 1\n        this.messages = []\n        const wrapkey = (obj: object, key: string) => {\n            // trace this function\n            const oldfn = obj[key]\n            obj[key] = (\n                ...args: ((\n                    ...args: (\n                        | string\n                        | HTMLElement\n                        | number\n                        | boolean\n                        | false\n                        | (string | HTMLElement | number | boolean | false)[]\n                    )[]\n                ) => void)[]\n            ) => {\n                this.fin(key, Array.prototype.slice.call(args))\n                const result = oldfn.apply(obj, args)\n                this.fout(key, result)\n                return result\n            }\n        }\n        // can't use Object.keys for prototype walking\n        for (let key in obj) {\n            if (typeof obj[key] === \"function\") {\n                wrapkey(obj, key)\n            }\n        }\n        this.log(\" TRACELOG START\")\n    }\n    // called when entering a function\n    fin(\n        fn: string,\n        args:\n            | string\n            | HTMLElement\n            | number\n            | boolean\n            | false\n            | (string | HTMLElement | number | boolean | false)[],\n    ) {\n        this.padding += this.pad\n        this.log(`> entering ${fn}`, args)\n    }\n    // called when exiting a function\n    fout(\n        fn: string,\n        result:\n            | string\n            | HTMLElement\n            | number\n            | boolean\n            | false\n            | (string | HTMLElement | number | boolean | false)[],\n    ) {\n        this.log(\"< generated return value\", result)\n        this.padding = this.padding.substring(\n            0,\n            this.padding.length - this.pad.length,\n        )\n    }\n    // log message formatting\n    format(s: string, tick: number) {\n        let nf = function (t: number) {\n            let tStr = `${t}`\n            while (tStr.length < 4) {\n                tStr = `0${t}`\n            }\n            return tStr\n        }\n        return `${nf(tick)}> ${this.padding}${s}`\n    }\n    // log a trace message\n    log(...args) {\n        const stringCollapse = function (\n            v:\n                | string\n                | HTMLElement\n                | number\n                | boolean\n                | false\n                | (string | HTMLElement | number | boolean | false)[],\n        ) {\n            if (!v) {\n                return \"<falsey>\"\n            }\n            if (typeof v === \"string\") {\n                return v\n            }\n            // Use simplified check for HTMLElement since this is outside the main diff process\n            if (checkElementType(v, true, \"HTMLElement\")) {\n                return (v as HTMLElement).outerHTML || \"<empty>\"\n            }\n            if (v instanceof Array) {\n                return `[${v.map(stringCollapse).join(\",\")}]`\n            }\n            return v.toString() || v.valueOf() || \"<unknown>\"\n        }\n        const s = args.map(stringCollapse).join(\", \")\n        this.messages.push(this.format(s, this.tick++))\n    }\n    // turn the log into a structured string with\n    // unicode box codes to make it a sensible trace.\n    toString() {\n        let cap = \"   \"\n        let terminator = \"\"\n        while (terminator.length <= this.padding.length + this.pad.length) {\n            terminator += cap\n        }\n        let _ = this.padding\n        this.padding = \"\"\n        terminator = this.format(terminator, this.tick)\n        this.padding = _\n        return `${this.messages.join(\"\\n\")}\\n${terminator}`\n    }\n}\n"],"names":["__assign","Object","assign","t","s","i","n","arguments","length","p","prototype","hasOwnProperty","call","apply","this","__spreadArray","to","from","pack","ar","l","Array","slice","concat","SuppressedError","Diff","options","_this","entries","forEach","_a","key","value","toString","JSON","stringify","setValue","aKey","aValue","checkElementType","element","simplifiedCheck","elementTypeNames","_i","some","elementTypeName","nodeType","nodeName","startsWith","endsWith","tagName","toLowerCase","_b","ownerDocument","defaultView","objToNode","objNode","insideSvg","node","document","createTextNode","data","createComment","createElementNS","createElement","attributes","setAttribute","childNodes","childNode","appendChild","valueDiffing","simplifiedElementCheck","checked","selected","getFromRoute","route","c","splice","applyDiff","tree","diff","newNode","reference","action","_const","addElement","addTextElement","includes","info","preDiffApply","addAttribute","name","modifyAttribute","newValue","removeAttribute","modifyTextElement","textDiff","oldValue","parentNode","modifyValue","modifyComment","modifyChecked","modifySelected","replaceElement","namespaceURI","replaceChild","relocateGroup","groupLength","map","removeChild","index","insertBefore","removeElement","parentRoute","removeTextElement","console","log","postDiffApply","swap","obj","p1","p2","tmp","undoDOM","diffs","reverse","undoDiff","elementDescriptors","el","output","push","replace","id","findUniqueDescriptors","li","uniqueDescriptors","duplicateDescriptors","descriptor","inUnique","uniqueInBoth","l1","l2","l1Unique","l2Unique","inBoth","keys","removeDone","outerDone","innerDone","valueDone","every","cleanNode","diffNode","elementNode","diffChildNode","isEqual","e1","e2","Boolean","e1Attributes","e2Attributes","attribute","roughlyEqual","sameSiblings","preventRecursion","nodeList1","nodeList2","childUniqueDescriptors_1","makeBooleanArray","v","markSubTrees","oldTree","newTree","oldChildren","newChildren","marked1","marked2","subsets","returnIndex","foundAllSubsets","subset","c1","c2","lcsSize","c1Length","c2Length","matches","subsetsSame","c1Desc","c2Desc","description","c1Index","c1Element","c2Index","c2Element","findCommonSubsets","item","markBoth","subsetsAge","DiffTracker","list","add","fn","getFromVirtualRoute","nodeIndex","undefined","applyVirtual","routeInfo","newSubsets","preVirtualDiffApply","movedNode","splitLength","c_1","c_2","filter","postVirtualDiffApply","applyVirtualDiff","nodeToObj","aNode","type","tagRE","attrRE","unescape","string","lookup","area","base","br","col","embed","hr","img","input","keygen","link","menuItem","meta","param","source","track","wbr","parseTag","tag","caseSensitive","res","voidElement","tagMatch","match","toUpperCase","charAt","endIndex","indexOf","reg","RegExp","result","done","exec","trim","attr","arr","split","lastIndex","substring","stringToObj","html","current","level","end","isOpen","isComment","start","nextChar","comment","parent_1","parent_2","DiffFinder","t1Node","t2Node","t1","Element","parse","t2","diffcount","foundAll","debug","t1Orig","t2Orig","tracker","init","findDiffs","diffcap","Error","findNextDiff","error","fdiffs","maxDepth","findOuterDiff","filterOuterDiff","findInnerDiff","findValueDiff","attr1","attr2","attrLength","pos","Math","abs","sort","t1ChildNodes","t2ChildNodes","last","max","childNodesLengthDifference","maxChildCount","cachedSubtrees","subtrees","attemptGroupRelocation","destinationDifferent","toGroup","group","similarNode","gapInformation","stable","gaps1","gaps2","endOld","endNew","j","getGapInformation","shortest","min","index2","index1","testI","DEFAULT_OPTIONS","currentValue","expectedValue","compress","window","components","DiffDOM","varNames","constNames_1","varName","applyDOM","undo","TraceLogger","pad","padding","tick","messages","wrapkey","oldfn","args","fin","fout","format","tStr","nf","stringCollapse","outerHTML","join","valueOf","terminator","_"],"mappings":"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","x_google_ignoreList":[0]}